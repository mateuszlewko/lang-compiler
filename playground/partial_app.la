external ll_putint     : int -> () 
external ll_print_line : ()  -> () 

let pn () : () = ll_print_line () 

let p_int x = 
    ll_putint x
    pn ()

let print_add x y = 
    let sum p = x + y - p
    let s = sum -1
    ll_putint s
    s 

(* 
type 'a : (Eq, Ord, Show) is Enum with 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class<'a : Eq, Ord, Show, 'b : Eq, Cmp> Enum  where 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class 'a : Ord => 

class Enum 'a : Ord where 
    

type 'a is Print with 
    print : 'a -> ()

instance Print Int where 
    let print i = ll_putint i 

instance Print Int where 
    let print i = ll_putint i 

impl Print for Int with 
    let print i = ll_putint i 

class Enum ('a : Eq, Ord, Show) where 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class (Eq 'a, Ord 'a, Show 'a) => Enum 'a where
    succ  : 'a -> 'a
    isEnd : 'a -> Bool  
*)


(* class Enum ('a : Eq, Ord, Show) where 
    succ  : 'a -> 'a
    isEnd : 'a -> bool
    isEnd : 'a -> bool

class Enum2 ('a : Eq, Ord, Show) where succ : 'a -> 'a

instance Enum int where 
    let print i = ll_putint i 

    let isEnd i = 
        false

    let rec succ i = 
        if i = 0 then i 
        else succ (i - 1)

let cmp1 (x : 'a) (y : 'a) : int when 'a : Eq = 
    if x = y 
    then 0 
    else 1

let cmp2 x y = x = y *)

class Eq 'xyz where eq : 'xyz -> 'xyz -> bool 
class Lt 'xyz where lt : 'xyz -> 'xyz -> bool 

let not (b : bool) : bool = 
    if b 
    then false 
    else true

instance Lt bool where 
    let lt a b = 
        if (not a) && b 
        then true 
        else false

instance Eq int where
    let eq a b = a = b 
 
instance Lt int where 
    let lt a b = a < b 

instance Eq bool where
    let eq a b =
        if (a && b) || ((not a) && (not b)) 
        then true 
        else false 

(* val leq : 'a -> 'a -> 'a when 'a : (Eq, Lt)  *)
(* val leq : (Eq 'a, Lt 'a) => a -> 'a -> 'a  *)

let leq (l : 'a) (r : 'a) : bool when 'a : (Eq, Lt) =
    if (eq l r) || (lt l r)
    then true 
    else false

let leq_int l r : bool = leq l r 

let leq_bool (l : bool) (r : bool) : bool = leq l r 

let p_bool (b : bool) : () =
    if b 
    then ll_putint 1
    else ll_putint 0
    pn ()

let rec f1 acc a =
    if a = 0 
    then acc 
    elif a = 1
    then acc + (f3 a)
    else f1 (acc + 2) (a - 1) 

and f3 a = 
    if a = 1
    then f1 1 0
    else f4 (a - 1)

and f4 a = f1 0 a

let gen_apply ff a b = ff a b 

let gen_apply2 gen ff a b = gen ff a b 

let gen_apply3 f_id (ff : 'b -> 'b -> 'b) a b = f_id (ff a b)

let id x = x

let nested_recs () = 
    let rec af1 acc a =
        if a = 0 
        then acc 
        elif a = 1
        then acc + (af3 a)
        else 3
        (* af1 (acc + 2) (a - 1)  *)

    and af3 a = 
        if a = 1
        then af1 1 0
        else af4 (a - 1)

    and af4 a = af1 0 a

    p_int (af4 3)
    p_int (af3 2)
    p_int (af1 0 10)
    pn ()
    0

let rec add1 (cycle : bool) (x : int) : int = 
    if cycle
    then add2 (x + 1)
    else x

and add2 x = add3 (x + 1)
and add3 x = add4 (x + 1)
and add4 x = add5 (x + 1)
and add5 x = add6 (x + 1)
and add6 x = add1 false (x + 1)

let _ : () = 
    gen_apply print_add 1 3 
    pn ()
    pn ()
    gen_apply2 gen_apply print_add 1 3 
    pn ()
    pn ()
    gen_apply3 id print_add 1 3
    pn ()
    pn () 
   
    nested_recs ()
    pn()

    ll_putint (add2 3)
    pn () 
    pn ()

    p_int (f4 3)
    p_int (f3 2)
    p_int (f1 0 10)
    pn ()

    p_bool (leq 1 2)
    p_bool (leq 1 1)
    p_bool (leq 121 9)
    pn () 
    pn () 

    p_bool (leq false true)
    p_bool (leq true true)
    p_bool (leq false false)
    p_bool (leq true false)
    pn ()
    pn ()

    p_bool (leq 1 2)
    p_bool (leq 1 1)
    p_bool (leq 121 9)
    pn () 

(* 
let rec range (first : 'a) (last : 'a) : 'a when 'a : (Enum, Eq), 'b : Enum =
    if first = last 
    then [| |]
    else first + range (succ first) last  *)
(* 
let just_call (fn : int -> int -> int) x y =
    fn x y

let id (x : 'a) : 'a = x
(* let id2 (x : 'a) : 'a = x *)

type point2 = { x : int; y : int }
type point3 = { x : int; y : int; z : int }

let p3Get (p : point3) = p.z 
let p3GetZ (p : point3) = p.z 
let p2Get (p : point2) = p.x 

let printAnd (x : 'a) (getter : 'a -> int) : 'a =
    ll_putint (getter x)
    pn ()
    x

let compose (f : 'a -> 'b) (g : 'b -> 'c) (a : 'a) : 'c = 
    g (f (a))

let getPrint (get : 'a -> int) (arg: 'a) : () = 
    ll_putint (get arg)
    pn () 

let test1 (x : int) (p : point2) : () = 
    getPrint id x 
    getPrint p2Get p 

let _ : () =
    test1 3 { x = 1; y = 2 } 
    pn ()
    pn ()
    pn ()
    
    (* let  *)
    just_call print_add 2 3 
    pn ()
    ll_putint (id 3)
    pn ()

    let x : point2 = printAnd { x = 1; y = 2 } p2Get
    ll_putint x.x 
    pn ()

    let p3 : point3 = { x = 3; y = 4; z = 5 }

    printAnd { x = 3; y = 4; z = 5 } p3Get

    let add5 x = x + 5

    pn ()
    let res = compose p3GetZ add5 p3 
    ll_putint res 
    pn ()
    
    let res = compose p2Get add5 { x = 1; y = 2 }
    ll_putint res 
    pn ()


    () *)


(* let main () =
    (test1 100 2 100) 10 11 *)

(* OCaml version *)
(*
let adder5 a b c d e = a + b + c + d + e 

let adder3 a b c : int -> int -> int = 
    adder5 a b c

let apply2 which (f3 : int -> int -> int) (g3 : int -> int -> int) () = 
    if which = 1
    then (f3 1 2) + (f3 3 10) 
    else if which = 2 
    then (f3 1 2) + (f3 3 11)
    else (f3 1 2) + (f3 3 12)

let rec test (fn : unit -> int) cnt = 
    if cnt = 0
    then fn ()
    else (
        fn ();
        test fn (cnt - 1)
    )

let main  = test (apply2 2 (adder3 5 6 7) (adder3 8 9 10)) 100000000

*)