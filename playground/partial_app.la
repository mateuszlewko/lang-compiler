external ll_putint     : int -> () 
external ll_print_line : ()  -> () 

let pn () : () = ll_print_line () 

let print_add x y = 
    let sum p = x + y - p
    let s = sum -1 
    ll_putint (sum -1)
    s  

let just_call (fn : int -> int -> int) x y =
    fn x y

let id (x : 'a) : 'a = x

type point2 = { x : int; y : int }
type point3 = { x : int; y : int; z : int }

let p3Get (p : point3) = p.z 
let p3GetZ (p : point3) = p.z 
let p2Get (p : point2) = p.x 

let printAnd (x : 'a) (getter : 'a -> int) : 'a =
    ll_putint (getter x)
    pn ()
    x

let compose (f : 'a -> 'b) (g : 'b -> 'c) (a : 'a) : 'c = 
    g (f (a))

let _ : () =
    pn ()
    pn ()
    pn ()
    
    (* let  *)
    just_call print_add 2 3 
    pn ()
    ll_putint (id 3)
    pn ()

    let x : point2 = printAnd { x = 1; y = 2 } p2Get
    ll_putint x.x 
    pn ()

    let p3 : point3 = { x = 3; y = 4; z = 5 }

    printAnd { x = 3; y = 4; z = 5 } p3Get

    let add5 x = x + 5

    pn ()
    let res = compose p3GetZ add5 p3 
    ll_putint res 
    pn ()
    
    let res = compose p2Get add5 { x = 1; y = 2 }
    ll_putint res 
    pn ()


    ()


(* let main () =
    (test1 100 2 100) 10 11 *)

(* OCaml version *)
(*
let adder5 a b c d e = a + b + c + d + e 

let adder3 a b c : int -> int -> int = 
    adder5 a b c

let apply2 which (f3 : int -> int -> int) (g3 : int -> int -> int) () = 
    if which = 1
    then (f3 1 2) + (f3 3 10) 
    else if which = 2 
    then (f3 1 2) + (f3 3 11)
    else (f3 1 2) + (f3 3 12)

let rec test (fn : unit -> int) cnt = 
    if cnt = 0
    then fn ()
    else (
        fn ();
        test fn (cnt - 1)
    )

let main  = test (apply2 2 (adder3 5 6 7) (adder3 8 9 10)) 100000000

*)