(* let adder5 a b c d e = a + b + c + d + e 

let adder3 a b c : int -> int -> int = 
    adder5 a b c

let apply2 which (f3 : int -> int -> int) (g3 : int -> int -> int) () = 
    if which = 1
    then (f3 1 2) + (f3 3 10) 
    elif which = 2 
    then (f3 1 2) + (f3 3 11)
    else (f3 1 2) + (f3 3 12)

let rec test (fn : unit -> int) cnt = 
    if cnt = 0
    then fn ()
    else 
        fn ()
        test fn (cnt - 1) *)

external ll_putint     : int -> () 
external ll_print_line : ()  -> () 

type Point = {
        x : int 
        y : int 
    }

type point1 = 
    {
        x : int 
        y : int 
    }

type point2 = { x : int; y : int }

type point3 = { x : int; y : int 
              ; z : int }

type point4 = { x : int; y : int 
    z : int}

type point5 = { x : int; y : int ;
    z2 : int}

(* 

let a : point1 = { x = 1; y = 2 }
a.x.y // getter
{ (fn a).x with 
    y = 3 } 

*)

let funA1 x = x

module ModA = 
    let funA2 y = 
        let x = 3
        let z0 = (x x).d
        let z1 = (x.x).d
        let z2 = x.x.d
        let z3 = X.A.d.d
        let z4 = (fn (a + 5) x) . d . g

        (funA1 y) + y

module Add = 
    let adder5b a b c : int -> int -> int = 
        let innerAdder d e = 
            a + b + c + d + e

        let x1 = 
            {
              a = 2; 
               b = 3
            }

        let x1 = 
           {a = 4 
            b = 5
           }

        let x2 = 
            { a = 4 
              b = 55
              c = a + 4 
            }

        let x3 = { a = fn 4; b= fn 5 + 9  }.a
       
        let x2b = 
            { a = 4 
              b = 55
              c
            }

        let x3b = { a; b= fn 5 + 9; c  }.a

        let u1 = 
            { r with a = 3
                 b = 4 + 5
                 ; c; d = 2
            }

        let u2 = 
            { fn b with a = 3; d }
        
        let u3 =  { fn b with a = 3 }
        
        innerAdder

open Add 

let printn (p : int -> ()) v : () = 
    p v 
    ll_print_line ()
(* let main () = test (apply2 2 (adder3 5 6 7) (adder3 8 9 10)) 100000000  *)

let my_main () =
    let tmp (fn : int -> int -> int -> int -> int -> int) x y : int -> int -> int = 
        fn x y 3
    (* let tmp2 : int -> int -> int = tmp 1 2
    let tmp3 : int -> int -> int = tmp2 *)
    (* let my_fn x : int -> int -> int -> int -> int = adder5b x *)
    let a1 x : int -> int = 
        ll_putint 1
        ll_print_line ()
        (tmp adder5b 1 x) -3

    let res = (a1 2 0) + (a1 3 0)
    
    printn ll_putint res
    0

let other_top = 
    ll_putint 11
    ll_print_line ()
    2
let top = 
    ll_putint 22
    ll_print_line ()
    2 + other_top

let eff = 
    ll_putint top 
    ll_print_line ()
    my_main ()

let pn () : () = ll_print_line ()

let top2 = 
    ll_putint 33
    pn ()
    2 + other_top


(* let main () =
    (test1 100 2 100) 10 11 *)

(* OCaml version *)
(*
let adder5 a b c d e = a + b + c + d + e 

let adder3 a b c : int -> int -> int = 
    adder5 a b c

let apply2 which (f3 : int -> int -> int) (g3 : int -> int -> int) () = 
    if which = 1
    then (f3 1 2) + (f3 3 10) 
    else if which = 2 
    then (f3 1 2) + (f3 3 11)
    else (f3 1 2) + (f3 3 12)

let rec test (fn : unit -> int) cnt = 
    if cnt = 0
    then fn ()
    else (
        fn ();
        test fn (cnt - 1)
    )

let main  = test (apply2 2 (adder3 5 6 7) (adder3 8 9 10)) 100000000

*)