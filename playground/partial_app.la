external ll_putint     : int -> () 
external ll_print_line : ()  -> () 

let pn () : () = ll_print_line () 

let print_add x y = 
    let sum p = x + y - p
    let s = sum -1 
    ll_putint (sum -1)
    s  
(* 
type 'a : (Eq, Ord, Show) is Enum with 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class<'a : Eq, Ord, Show, 'b : Eq, Cmp> Enum  where 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class 'a : Ord => 

class Enum 'a : Ord where 
    

type 'a is Print with 
    print : 'a -> ()

instance Print Int where 
    let print i = ll_putint i 

instance Print Int where 
    let print i = ll_putint i 

impl Print for Int with 
    let print i = ll_putint i 

class Enum ('a : Eq, Ord, Show) where 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class (Eq 'a, Ord 'a, Show 'a) => Enum 'a where
    succ  : 'a -> 'a
    isEnd : 'a -> Bool  
*)


(* class Enum ('a : Eq, Ord, Show) where 
    succ  : 'a -> 'a
    isEnd : 'a -> bool
    isEnd : 'a -> bool

class Enum2 ('a : Eq, Ord, Show) where succ : 'a -> 'a

instance Enum int where 
    let print i = ll_putint i 

    let isEnd i = 
        false

    let rec succ i = 
        if i = 0 then i 
        else succ (i - 1)

let cmp1 (x : 'a) (y : 'a) : int when 'a : Eq = 
    if x = y 
    then 0 
    else 1

let cmp2 x y = x = y *)

class Eq 'a where eq : 'a -> 'a -> bool 
class Lt 'a where lt : 'a -> 'a -> bool 

let not (b : bool) : bool = 
    if b 
    then false 
    else true

instance Eq int where
    let eq a b : bool = a = b 

instance Lt int where 
    let lt a b : bool = a < b 

(* instance Eq bool where
    let eq (a : bool) (b : bool) : bool = a = b

instance Lt bool where 
    let lt (a : bool) (b : bool) : bool = a < b  *)

let leq (l : 'a) (r : 'a) : bool when 'a : (Eq, Lt) =
    if (eq l r) || (lt l r)
    then true 
    else false

let leq_int l r : bool = leq l r 

let p_bool (b : bool) : () =
    if b 
    then ll_putint 1
    else ll_putint 0
    pn ()

let _ : () = 
    p_bool (leq_int 1 2)
    p_bool (leq_int 1 1)
    p_bool (leq_int 121 9)
    pn ()


(* 
let rec range (first : 'a) (last : 'a) : 'a when 'a : (Enum, Eq), 'b : Enum =
    if first = last 
    then [| |]
    else first + range (succ first) last  *)
(* 
let just_call (fn : int -> int -> int) x y =
    fn x y

let id (x : 'a) : 'a = x
(* let id2 (x : 'a) : 'a = x *)

type point2 = { x : int; y : int }
type point3 = { x : int; y : int; z : int }

let p3Get (p : point3) = p.z 
let p3GetZ (p : point3) = p.z 
let p2Get (p : point2) = p.x 

let printAnd (x : 'a) (getter : 'a -> int) : 'a =
    ll_putint (getter x)
    pn ()
    x

let compose (f : 'a -> 'b) (g : 'b -> 'c) (a : 'a) : 'c = 
    g (f (a))

let getPrint (get : 'a -> int) (arg: 'a) : () = 
    ll_putint (get arg)
    pn () 

let test1 (x : int) (p : point2) : () = 
    getPrint id x 
    getPrint p2Get p 

let _ : () =
    test1 3 { x = 1; y = 2 } 
    pn ()
    pn ()
    pn ()
    
    (* let  *)
    just_call print_add 2 3 
    pn ()
    ll_putint (id 3)
    pn ()

    let x : point2 = printAnd { x = 1; y = 2 } p2Get
    ll_putint x.x 
    pn ()

    let p3 : point3 = { x = 3; y = 4; z = 5 }

    printAnd { x = 3; y = 4; z = 5 } p3Get

    let add5 x = x + 5

    pn ()
    let res = compose p3GetZ add5 p3 
    ll_putint res 
    pn ()
    
    let res = compose p2Get add5 { x = 1; y = 2 }
    ll_putint res 
    pn ()


    () *)


(* let main () =
    (test1 100 2 100) 10 11 *)

(* OCaml version *)
(*
let adder5 a b c d e = a + b + c + d + e 

let adder3 a b c : int -> int -> int = 
    adder5 a b c

let apply2 which (f3 : int -> int -> int) (g3 : int -> int -> int) () = 
    if which = 1
    then (f3 1 2) + (f3 3 10) 
    else if which = 2 
    then (f3 1 2) + (f3 3 11)
    else (f3 1 2) + (f3 3 12)

let rec test (fn : unit -> int) cnt = 
    if cnt = 0
    then fn ()
    else (
        fn ();
        test fn (cnt - 1)
    )

let main  = test (apply2 2 (adder3 5 6 7) (adder3 8 9 10)) 100000000

*)