external ll_putint     : int -> () 
external ll_print_line : ()  -> () 

let pn () : () = ll_print_line () 

let p_int x = 
    ll_putint x
    pn ()

let print_add x y = 
    let sum p = x + y - p
    let s = sum -1
    ll_putint s
    s 

(* 
type 'a : (Eq, Ord, Show) is Enum with 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class<'a : Eq, Ord, Show, 'b : Eq, Cmp> Enum  where 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class 'a : Ord => 

class Enum 'a : Ord where 
    

type 'a is Print with 
    print : 'a -> ()

instance Print Int where 
    let print i = ll_putint i 

instance Print Int where 
    let print i = ll_putint i 

impl Print for Int with 
    let print i = ll_putint i 

class Enum ('a : Eq, Ord, Show) where 
    succ  : 'a -> 'a
    isEnd : 'a -> Bool 

class (Eq 'a, Ord 'a, Show 'a) => Enum 'a where
    succ  : 'a -> 'a
    isEnd : 'a -> Bool  
*)


(* class Enum ('a : Eq, Ord, Show) where 
    succ  : 'a -> 'a
    isEnd : 'a -> bool
    isEnd : 'a -> bool

class Enum2 ('a : Eq, Ord, Show) where succ : 'a -> 'a

instance Enum int where 
    let print i = ll_putint i 

    let isEnd i = 
        false

    let rec succ i = 
        if i = 0 then i 
        else succ (i - 1)

let cmp1 (x : 'a) (y : 'a) : int when 'a : Eq = 
    if x = y 
    then 0 
    else 1

let cmp2 x y = x = y *)

class Eq 'xyz where eq : 'xyz -> 'xyz -> bool 
class Lt 'xyz where lt : 'xyz -> 'xyz -> bool 

let not (b : bool) : bool = 
    if b 
    then false 
    else true

instance Lt bool where 
    let lt a b = 
        if (not a) && b 
        then true 
        else false

instance Eq int where
    let eq a b = a = b 
 
instance Lt int where 
    let lt a b = a < b 

instance Eq bool where
    let eq a b =
        if (a && b) || ((not a) && (not b)) 
        then true 
        else false 

(* val leq : 'a -> 'a -> 'a when 'a : (Eq, Lt)  *)
(* val leq : (Eq 'a, Lt 'a) => a -> 'a -> 'a  *)

let leq (l : 'a) (r : 'a) : bool when 'a : (Eq, Lt) =
    if (eq l r) || (lt l r)
    then true 
    else false

let leq_int l r : bool = leq l r 

let leq_bool (l : bool) (r : bool) : bool = leq l r 

let p_bool (b : bool) : () =
    if b 
    then ll_putint 1
    else ll_putint 0
    pn ()

let rec f1 acc a =
    if a = 0 
    then acc 
    elif a = 1
    then acc + (f3 a)
    else f1 (acc + 2) (a - 1) 

and f3 a = 
    if a = 1
    then f1 1 0
    else f4 (a - 1)

and f4 a = f1 0 a

let gen_apply ff a b = ff a b 

let gen_apply2 gen ff a b = gen ff a b 

let gen_apply3 f_id ff a b = f_id (ff a b)

let id x = x

(* let nested_recs () = 
    let rec af1 acc a =
        if a = 0 
        then acc 3
        elif a = 1
        then acc + (af3 a)
        else 3
        (* af1 (acc + 2) (a - 1)  *)

    and af3 a = 
        if a = 1
        then af1 1 0
        else af4 (a - 1)

    and af4 a = af1 0 a

    p_int (af4 3)
    p_int (af3 2)
    p_int (af1 0 10)
    pn ()
    0 *)

let rec af1 acc a = 
    if a = 0 
    then acc
    elif a = 1
    then (af3 a) + acc
    else 3 
    (* af1 (acc + 2) (a - 1)  *)

and af3 a = 
    if a = 1
    then af1 1 0
    else af4 (a - 1)

and af4 a = 
    af1 0 a

let nested_recs () : int = 
     (* let rec add1 add2a add3a cycle x = 
        if cycle
        then add2a add1 add3a (x + 1)
        else x

    let rec add2 add1a add3a x = 
        add3a add1a add2 (x + 1)
    let rec add3 add1a add2a x = add1a add2a add3 false (x + 1) *)

    (* let rec add1 add1a add2a x = 
        if x = 0
        then 0
        else add2a add1a add2a (x - 1)

    let rec add2 add1a add2a x = 
        add1a add1a add2a x *)
    

    (* let rec add1 add2 add3 add4 add5 add6 add7 add8 cycle x = 
        if cycle
        then add2 add1 add3 add4 add5 add6 add7 add8 (x + 1)
        else x

    let rec add2 add1 add3 add4 add5 add6 add7 add8 x = 
        add3 (x + 1)
    let rec add3 add4 x = add4 (x + 1)
    let rec add4 add5 x = add5 (x + 1)
    let rec add5 add6 x = add6 (x + 1)
    let rec add6 add7 x = add7 (x + 1)
    let rec add7 add8 x = add8 (x + 1)
    let rec add8 add1 add2 x = add1 add2 false (x + 1) *)

    (* ll_putint (add2 add1 add2 4) *)
    0


(* let rec add1.lifted add2 cycle x = ...

let rec add2.lifted add3 x = ...

let nested_recs 
    val add1_ptr = alloca fn  
    val add2_ptr = alloca fn 
    
    val add1_f = add1.lifted add2_ptr 

    Store (add1_ptr <- add1_f)
    Value (add1, add1_ptr) *)


(* let rec add1 next (cycle : bool) x = 
    if cycle
    then add2 next (next x)
    else x

and add2 next x = add3 next (next x)
and add3 next x = add4 next (next x)
and add4 next x = add5 next (next x)
and add5 next x = add6 next (next x)
and add6 next x = add1 next false (next x)
let add7 x = add4 (fun x -> x + 1) x *)

let rec some_fn x = x 
and just_pass x = other_fn x
and other_fn y = 5 + y

let _ : () = 
    gen_apply print_add 1 3 
    pn ()
    pn ()

    (* p_int (af4 3)
    p_int (af3 2)
    p_int (af1 0 10)
    pn () *)

    gen_apply2 gen_apply print_add 1 3 
    pn ()
    pn ()
    gen_apply3 id print_add 1 3
    pn ()
    pn () 
   
    ll_putint (nested_recs ())
    pn()

    (* ll_putint (add4 4) *)
    pn () 
    pn ()

    p_int (f4 3)
    p_int (f3 2)
    p_int (f1 0 10)
    pn ()

    p_bool (leq 1 2)
    p_bool (leq 1 1)
    p_bool (leq 121 9)
    pn () 
    pn () 

    p_bool (leq false true)
    p_bool (leq true true)
    p_bool (leq false false)
    p_bool (leq true false)
    pn ()
    pn ()

    p_bool (leq 1 2)
    p_bool (leq 1 1)
    p_bool (leq 121 9)
    pn () 

(* 
let rec range (first : 'a) (last : 'a) : 'a when 'a : (Enum, Eq), 'b : Enum =
    if first = last 
    then [| |]
    else first + range (succ first) last  *)
(* 
let just_call (fn : int -> int -> int) x y =
    fn x y

let id (x : 'a) : 'a = x
(* let id2 (x : 'a) : 'a = x *)

type point2 = { x : int; y : int }
type point3 = { x : int; y : int; z : int }

let p3Get (p : point3) = p.z 
let p3GetZ (p : point3) = p.z 
let p2Get (p : point2) = p.x 

let printAnd (x : 'a) (getter : 'a -> int) : 'a =
    ll_putint (getter x)
    pn ()
    x

let compose (f : 'a -> 'b) (g : 'b -> 'c) (a : 'a) : 'c = 
    g (f (a))

let getPrint (get : 'a -> int) (arg: 'a) : () = 
    ll_putint (get arg)
    pn () 

let test1 (x : int) (p : point2) : () = 
    getPrint id x 
    getPrint p2Get p 

let _ : () =
    test1 3 { x = 1; y = 2 } 
    pn ()
    pn ()
    pn ()
    
    (* let  *)
    just_call print_add 2 3 
    pn ()
    ll_putint (id 3)
    pn ()

    let x : point2 = printAnd { x = 1; y = 2 } p2Get
    ll_putint x.x 
    pn ()

    let p3 : point3 = { x = 3; y = 4; z = 5 }

    printAnd { x = 3; y = 4; z = 5 } p3Get

    let add5 x = x + 5

    pn ()
    let res = compose p3GetZ add5 p3 
    ll_putint res 
    pn ()
    
    let res = compose p2Get add5 { x = 1; y = 2 }
    ll_putint res 
    pn ()


    () *)


(* let main () =
    (test1 100 2 100) 10 11 *)

(* OCaml version *)
(*
let adder5 a b c d e = a + b + c + d + e 

let adder3 a b c : int -> int -> int = 
    adder5 a b c

let apply2 which (f3 : int -> int -> int) (g3 : int -> int -> int) () = 
    if which = 1
    then (f3 1 2) + (f3 3 10) 
    else if which = 2 
    then (f3 1 2) + (f3 3 11)
    else (f3 1 2) + (f3 3 12)

let rec test (fn : unit -> int) cnt = 
    if cnt = 0
    then fn ()
    else (
        fn ();
        test fn (cnt - 1)
    )

let main  = test (apply2 2 (adder3 5 6 7) (adder3 8 9 10)) 100000000

*)