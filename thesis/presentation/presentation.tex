\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{listings}
\usepackage[normalem]{ulem}
\usepackage{minted}

% \usepackage{syntax}

\usetheme{Warsaw}

\title[Implementacja~języka~funkcyjnego z~rodziny~ML]
{Implementacja~języka~funkcyjnego \newline z~rodziny~ML \newline
z wykorzystaniem infrastruktury LLVM}

\author{Mateusz Lewko}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.

% \institute[Universities of Somewhere and Elsewhere] % (optional, but mostly needed)
% {
%   \inst{1}%
%   Department of Computer Science\\
%   University of Somewhere
%   \and
%   \inst{2}%
%   Department of Theoretical Philosophy\\
%   University of Elsewhere}
% - Use the \inst command only if there are several affiliations.
% - Keep it simple, no one is interested in your street address.

% \date{Conference Name, 2013}
% - Either use conference name or its abbreviation.
% - Not really informative to the audience, more for people (including
%   yourself) who are reading the slides online

% \subject{Theoretical Computer Science}
% This is only inserted into the PDF information catalog. Can be left
% out. 

% If you have a file called "university-logo-filename.xxx", where xxx
% is a graphic format that can be processed by latex or pdflatex,
% resp., then you can add a logo as follows:

% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}

% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
% \AtBeginSubsection[]
% {
%   \begin{frame}<beamer>{Outline}
%     \tableofcontents[currentsection,currentsubsection]
%   \end{frame}
% }

% Let's get started
\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Spis treści}
  \tableofcontents
  % You might wish to add the option [pausesections]
\end{frame}

\section{Wstęp}

\subsection{Obecnie}
\begin{frame}{Obecnie}
\begin{itemize}
    \item {
        Jest wiele języków z rodziny ML
    \pause
    \item Zawierają
        \begin{itemize}
            \pause
            \item Polimorfizm parametryczny \pause
            \item Częściową aplikację \pause
            \item Zagnieżdżone funkcje \pause
            \item Funkcje wyższych rzędów \pause
            \item System modułów (OCaml, SML) lub obiektowe klasy (F\#) \pause
            \item Trwałe rekordy, funkcje wzajemnie rekurencyjne, 
            inferencja typów, algebraiczne typy danych, itp.
        \end{itemize}
    }
\end{itemize}
\end{frame}

\begin{frame}{Obecnie}
\begin{itemize}
    \item { 
        Jest wiele języków z rodziny ML
    \item Zawierają
        \begin{itemize}
            \item \textbf{Polimorfizm parametryczny $\rightarrow$ Opakowywanie 
            argumentów we wskaźnik}
            \item Częściową aplikację
            \item Zagnieżdżone funkcje 
            \item Funkcje wyższych rzędów 
            \item System modułów (OCaml, SML) lub obiektowe klasy (F\#)
            \item Trwałe rekordy, funkcje wzajemnie rekurencyjne, 
            inferencja typów, algebraiczne typy danych, itp.
        \end{itemize}
    }
\end{itemize}
\end{frame}

\begin{frame}{Obecnie}
\begin{itemize}
    \item {
        Jest wiele języków z rodziny ML
    \item Zawierają
        \begin{itemize}
            \item \textbf{Polimorfizm parametryczny $\Rightarrow$ Opakowywanie 
            argumentów we wskaźnik}
            \item Częściową aplikację
            \item Zagnieżdżone funkcje 
            \item Funkcje wyższych rzędów 
            \item \textbf{System modułów (OCaml, SML)} lub obiektowe klasy (F\#)
            \item Trwałe rekordy, funkcje wzajemnie rekurencyjne, 
            inferencja typów, 
            inferencja typów, algebraiczne typy danych, itp.
        \end{itemize}
    }
\end{itemize}
\end{frame}

\subsection{Motywacja}

\begin{frame}{Motywacja}
\begin{itemize}
    \item Wady opakowywania we wskaźnik
    \begin{itemize}
        \pause
        \item Narzut pamięciowy --- nawet 3x w przypadku typu int
        \pause
        \item Narzut czasowy 
        \begin{itemize}
            \item Automatyczne zarządzenie pamięcią
            \item Konieczność odczytywania pamięci ze sterty 
            \item Gorsze wykorzystanie pamięci cache
        \end{itemize}
    \end{itemize}

    \pause
    \item Wady systemu modułów
    \begin{itemize}
        \pause
        \item Brak możliwości przeładowaniu operatorów i funkcji (np. dla różnych 
        typów numerycznych)
        \pause
        \item Nietrywialne w implementacji i skomplikowane w użyciu
    \end{itemize}

\end{itemize}
\end{frame}

\subsection{Język MonoML}

\begin{frame}{Język MonoML}
\begin{itemize}
    \pause
    \item \textbf{Polimorfizm parametryczny $\rightarrow$ Monomorfizacja}
    \pause
    \item \textbf{Częściową aplikację $\rightarrow$ Bazowana na modelu
    push/enter}
    \pause
    \item \textbf{Klasy typów (ad--hoc polimorfizm)}
    \pause 
    \item Zagnieżdżone funkcje 
    \item Funkcje wyższych rzędów 
    \item Trwałe rekordy, funkcje wzajemnie rekurencyjne, inferencja typów
\end{itemize}
\end{frame}

\section{Polimorfizm Parametryczny}

\subsection{Opis problemu}

\begin{frame}[fragile]{Opis problemu}%{Optional Subtitle}
\begin{center}
\begin{minipage}{0.8\textwidth}
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Kod do skompilowania,
framesep=4mm]{ocaml}
  let twice f x = f (f x)
  let _ = 
    print_int   (twice identity 42  );
    print_float (twice identity 42.0)
\end{minted}
\pause
\pagebreak
\pagebreak
\begin{minted}[mathescape,
gobble=2,
% linenos,
fontsize=\small,
frame=single,
label=Wygenerowany LLVM IR \#1,
framesep=2mm]{llvm}
  define i32 @twice(i32 (i32)*, i32) {
      ...
  }
\end{minted}
\end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]{Opis problemu}%{Optional Subtitle}
\begin{center}
\begin{minipage}{0.8\textwidth}
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Kod do skompilowania,
framesep=4mm]{ocaml}
  let twice f x = f (f x)
  let _ = 
    print_int   (twice identity 42  );
    print_float (twice identity 42.0)
\end{minted}
\pagebreak
\pagebreak
\begin{minted}[mathescape,
gobble=2,
% linenos,
fontsize=\small,
frame=single,
label=Wygenerowany LLVM IR \#2,
framesep=2mm]{llvm}
  define float @twice(float (float)*, float) {
      ...
  }
\end{minted}
\end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]{Opis problemu}%{Optional Subtitle}
\begin{center}
\begin{minipage}{0.8\textwidth}
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Kod do skompilowania,
framesep=4mm]{ocaml}
  let twice f x = f (f x)
  let _ = 
    print_int   (twice identity 42  );
    print_float (twice identity 42.0)
\end{minted}
\pagebreak
\pagebreak
\begin{minted}[mathescape,
gobble=2,
% linenos,
fontsize=\small,
frame=single,
label=Argumenty opakowane we wskaźnik,
framesep=2mm]{llvm}
  define i8* @twice(i8* (i8*)*, i8*) {
      ...
  }
\end{minted}
\end{minipage}
\end{center}
\end{frame}

\subsection{Moje podejście --- Monomorfizacja}

\begin{frame}[fragile]{Moje podejście --- Monomorfizacja}
\begin{center}
\begin{minipage}{1.0\textwidth}
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Po monomorfizacji,
framesep=4mm]{ocaml}
  let twice_int (f : int -> int) (x : int) : int = 
    f (f x)
  let twice_float (f : float -> float) (x : float) 
    : float = f (f x)

  let _ = 
    print_int   (twice_int identity_int 42  );
    print_float (twice_float identity_float 42.0)
\end{minted}
\end{minipage}
\end{center}
\end{frame}

\subsection{Testy wydajnościowe}

\begin{frame}[fragile]{Testy wydajnościowe}{Cele}
    \begin{itemize}
    \item Porównanie czasów wykonania funkcji polimorficznej i monomorficznej
    \pause 
    \begin{itemize}
        \item w MonoMLu
        \pause
        \item w Haskellu, Javie i Standard MLu
    \pause
    \end{itemize}
    \item Narzut czasowy wywoływania funkcji w MonoMLu na tle innych języków
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Testy wydajnościowe}{Przygotowanie}
 \begin{center}
\begin{minipage}{1.0\textwidth}
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Funkcja polimorficzna,
framesep=4mm]{ocaml}
  let rec sum n (curr : 'a) (x : 'a) : 'a = 
      if n = 0 then curr 
      else sum (n - 1) (add curr x) x 
\end{minted}
\pause
\pagebreak
\pagebreak
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Monomorficzna,
framesep=4mm]{ocaml}
  let rec sum n (curr : int) (x : int) : int = 
      if n = 0 then curr 
      else sum (n - 1) (add curr x) x 
\end{minted}
\end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]{Testy wydajnościowe}{Przygotowanie}
 \begin{center}
\begin{minipage}{1.0\textwidth}
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Funkcja polimorficzna,
framesep=4mm]{ocaml}
    sumPoly :: Num a => Int -> a ->  a -> a
    sumPoly 0 curr _ = curr 
    sumPoly n curr x = sumPoly (n - 1) (curr + x) $! x
\end{minted}
\pagebreak
\pagebreak
\begin{minted}[mathescape,
gobble=2,
% linenos,
frame=single,
fontsize=\small,
label=Monomorficzna,
framesep=4mm]{ocaml}
    sumMono :: Int# -> Int# -> Int# -> Int# 
    sumMono 0# curr _ = curr 
    sumMono n curr x = sumMono (n -# 1#) (curr +# x) x
\end{minted}
\end{minipage}
\end{center}
\end{frame}

\begin{frame}[fragile]{Testy wydajnościowe}{Wyniki}
    
\begin{center}
\begin{table}
\begin{tabular}{|| l | l | r | r | r ||} 

 \hline
 Język & Wersja & Czas (ms) & $\sigma$ & x \\ 
 \hline\hline
 Haskell (GHC)        & Mono & \textbf{39.1}  & 8.2  & 0.10 \\ 
 Haskell (GHC)        & Poli & \textbf{696.8} & 63.2 & 1.86 \\ 
 \hline
\end{tabular}
\end{table}
\end{center}
\end{frame}

\begin{frame}[fragile]{Testy wydajnościowe}{Wyniki}
    
\begin{center}
\begin{table}
\begin{tabular}{|| l | l | r | r | r ||} 

 \hline
 Język & Wersja & Czas (ms) & $\sigma$ & x \\ 
 \hline\hline
 Haskell (GHC)        & Mono & 39.1  & 8.2  & 0.10 \\ 
 Haskell (GHC)        & Poli & 696.8 & 63.2 & 1.86 \\ 
 Java                 & Mono & \textbf{140.1} & 65.7 & 0.37 \\ 
 Java                 & Poli & \textbf{564.9} & 24.8 & 1.50 \\ 
 \hline
\end{tabular}
\end{table}
\end{center}
\end{frame}

\begin{frame}[fragile]{Testy wydajnościowe}{Wyniki}
    
\begin{center}
\begin{table}
\begin{tabular}{|| l | l | r | r | r ||} 

 \hline
 Język & Wersja & Czas (ms) & $\sigma$ & x \\ 
 \hline\hline
 Haskell (GHC)        & Mono & 39.1  & 8.2  & 0.10 \\ 
 Haskell (GHC)        & Poli    & 696.8 & 63.2 & 1.86 \\ 
 Java                 & Mono & 140.1 & 65.7 & 0.37 \\ 
 Java                 & Poli    & 564.9 & 24.8 & 1.50 \\ 
 SML (MLton)          & Mono & \textbf{151.0} & 13.7 & 0.40 \\ 
 SML (SML/NJ)         & Poli & \textbf{357.6} & 14.4 & 0.95 \\ 
 \hline
\end{tabular}
\end{table}
\end{center}
\end{frame}

\begin{frame}[fragile]{Testy wydajnościowe}{Wyniki}
    
\begin{center}
\begin{table}
\begin{tabular}{|| l | l | r | r | r ||} 

 \hline
 Język & Wersja & Czas (ms) & $\sigma$ & x \\ 
 \hline\hline
 Haskell (GHC)        & Mono & 39.1  & 8.2  & 0.10 \\ 
 Haskell (GHC)        & Poli    & 696.8 & 63.2 & 1.86 \\ 
 Java                 & Mono & 140.1 & 65.7 & 0.37 \\ 
 Java                 & Poli    & 564.9 & 24.8 & 1.50 \\ 
 SML (MLton)          & Mono & 151.0 & 13.7 & 0.40 \\ 
 SML (SML/NJ)         & Poli    & 357.6 & 14.4 & 0.95 \\ 
 Mono ML              & Mono & \textbf{327.0} & 52.3 & 0.88 \\ 
 Mono ML              & Poli & \textbf{375.4} & 46.9 & 1.00 \\ 
 \hline
\end{tabular}
\end{table}
\end{center}
\end{frame}




\section{Częściowa aplikacja}

\subsection{Another Subsection}

\begin{frame}{Blocks}
\begin{block}{Block Title}
You can also highlight sections of your presentation in a block, with it's own title
\end{block}
\begin{theorem}
There are separate environments for theorems, examples, definitions and proofs.
\end{theorem}
\begin{example}
Here is an example of an example block.
\end{example}
\end{frame}

\section{Klasy typów}

\begin{frame}{Blocks}
\begin{block}{Block Title}
You can also highlight sections of your presentation in a block, with it's own title
\end{block}
\begin{theorem}
There are separate environments for theorems, examples, definitions and proofs.
\end{theorem}
\begin{example}
Here is an example of an example block.
\end{example}
\end{frame}

% Placing a * after \section means it will not show in the
% outline or table of contents.
\section*{Podsumowanie}

\begin{frame}{Summary}
  \begin{itemize}
  \item
    The \alert{first main message} of your talk in one or two lines.
  \item
    The \alert{second main message} of your talk in one or two lines.
  \item
    Perhaps a \alert{third message}, but not more than that.
  \end{itemize}
  
  \begin{itemize}
  \item
    Outlook
    \begin{itemize}
    \item
      Something you haven't solved.
    \item
      Something else you haven't solved.
    \end{itemize}
  \end{itemize}
\end{frame}

% All of the following is optional and typically not needed. 
\appendix
\section<presentation>*{\appendixname}
\subsection<presentation>*{For Further Reading}

\begin{frame}[allowframebreaks]
  \frametitle<presentation>{For Further Reading}
    
  \begin{thebibliography}{10}
    
  \beamertemplatebookbibitems
  % Start with overview books.

  \bibitem{Author1990}
    A.~Author.
    \newblock {\em Handbook of Everything}.
    \newblock Some Press, 1990.
 
    
  \beamertemplatearticlebibitems
  % Followed by interesting articles. Keep the list short. 

  \bibitem{Someone2000}
    S.~Someone.
    \newblock On this and that.
    \newblock {\em Journal of This and That}, 2(1):50--100,
    2000.
  \end{thebibliography}
\end{frame}

\end{document}


