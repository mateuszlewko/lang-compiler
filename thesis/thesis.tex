% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia się przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[declaration,shortabstract]{iithesis}

% \usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[epsilon]{backnaur}
\usepackage{url}
\usepackage{caption}
\usepackage[numbers,square]{natbib}

% \usepackage{tikz}
% \usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
%     decorations.pathreplacing,decorations.pathmorphing,shapes,%
%     matrix,shapes.symbols}

% \usepackage{titlesec}
% \titlespacing*{\section}{0pt}{1.1\baselineskip}{\baselineskip}

% \usepackage{color}

% \definecolor{dkgreen}{rgb}{0,0.6,0}
% \definecolor{gray}{rgb}{0.5,0.5,0.5}
% \definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=lines,
  language=Caml,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
%   numberstyle=\tiny\color{gray},
%   keywordstyle=\color{blue},
%   commentstyle=\color{dkgreen},
%   stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=true,
  tabsize=3
}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Implementacja~języka~funkcyjnego \newline z~rodziny~ML \newline
z wykorzystaniem infrastruktury LLVM }
\englishtitle   
{An implementation of a ML-family functional language 
\newline using the LLVM compiler infrastructure}
\polishabstract {
Tematem niniejszej pracy jest eksperymentalna implementacja modelowego języka 
funkcyjnego \textit{MonoML}, która zapewnienia efektywną obsługę częściowej 
aplikacji funkcji i polimorfizmu parametrycznego przy jednoczesnym wsparciu dla
\textit{ad--hoc} polimorfizmu w postaci klas typów.
Popularne kompilatory języków funkcyjnych z rodziny ML często charakteryzują się 
podobnymi kompromisami przy implementacji częściowej aplikacji i polimorfizmu 
parametrycznego. Zazwyczaj wymagają jednorodnej reprezentacji danych, więc 
opakowują wszystkie polimorficzne argumenty we wskaźnik. 
Głównym celem tej pracy jest zastosowanie monomorfizacji w procesie kompilacji 
języka MonoML, co pozwala na uniknięcie jednorodnej reprezentacji danych.
% Częścią tej pracy jest implementacja 
% W swojej pracy przedstawię // Czas przyszły - źle
% implementację 
% kompilatora języka funkcyjnego \textit{MonoML},
% w której dzięki monomorfizacji unikam jednorodnej reprezentacji danych.
% w której unikam jednorodnej 
% reprezentacji danych przez wskaźnik dzięki monomorfizacji. 
                            %   // związany z implementacją 
Zmniejszając narzut czasowy związany z implementacją funkcji polimorficznych,
decyduję się na zwiększenie rozmiaru wygenerowanego programu.
Moja implementacja częściowej aplikacji, choć bazowana na popularnym modelu 
\textit{push/enter}, radzi sobie z problemem manualnego zarządzania stosem.

Drugim celem pracy jest implementacja prostych klas typów w języku z rodziny ML, 
co prowadzi do wzbogacenia języka o \textit{ad--hoc} polimorfizm. 
Są one głównym elementem 
języka pozwalającym na modularyzację programu. Odbiega to od standardowo 
stosowanego systemu modułów w większości języków z rodziny ML. 
Monomorfizacja funkcji pozwala na statyczne 
wybranie odpowiednich instancji klasy. 
}

% Main goal of this thesis is experimental compiler of 
% functional programming language --- \textit{MonoML}, with effective
\englishabstract{In this thesis I present an experimental compiler for 
\textit{MonoML} --- a functional programming language with efficient 
implementation of 
partial application and parametric polymorphism while offering \textit{ad--hoc}
polymorphism in a form of type classes. 
Popular compilers for ML-family functional programming 
languages, often made similar trade-offs when implementing partial application
and parametric polymorphism. They usually require uniform type representation 
which leads to boxing of all polymorphic arguments. 
Main goal of this thesis is to apply monomorphization during compilation phase, 
which allows to avoid uniform data representation.
% In this thesis I present 
% an implementation of a compiler for \textit{MonoML} --- 
% a functional programming language, 
% in which I choose to avoid uniform data representation by boxing. 
Monomorphization allows to decrease time overhead for polymorphic functions,
however it increases overall code size. My implementation of 
partial application is based on the \textit{push/enter} model. 
However, I manage to overcome the
issue of manual stack management, related to \textit{push/enter} model.

Another goal of this thesis is to introduce \textit{ad--hoc} polymorphism in 
a ML-family programming language, 
by implementing \textit{type classes} in \textit{MonoML}. 
They are the main feature which 
allows to modularize programs. This approach is different from modules 
which are usually present in ML-family languages. Monomorphization 
allows us to statically choose an appropriate instance for each class.
}

% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Mateusz Lewko}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr hab. Dariusz Biernacki}
\date           {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
% \transcriptnum {283197}                     % Numer indeksu
%\advisorgen    {dr. Jana Kowalskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

% \newenvironment{bnfsplit}[1][0.3\textwidth]
%  {\minipage[t]{#1}$}
%  {$\endminipage}

\begin{document}
%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Wprowadzenie}
Pierwsze prace nad językiem ML zaczął Robin Milner na początku lat 70. W~1984, 
dzięki jego inicjatywie, powstał Standard ML --- standaryzowana wersja języka 
ML. Już wtedy zawierał m.in. rozwijanie funkcji, dopasowanie do wzorca, 
inferencje typów oraz moduły parametryczne \cite{sml_proposal}. Są to elementy,
które cechują większość dzisiejszych języków programowania 
wywodzących się z SMLa takich jak OCaml i F\#. 

Wysokopoziomowe funkcjonalności
języków funkcyjnych, takie jak częściowa aplikacja i polimorfizm parametryczny, 
wiążą się z dodatkowym narzutem pamięciowym i czasowym. W wielu kompilatorach 
implementacja polimorfizmu parametrycznego wiążę się z koniecznością 
zastosowania jednorodnej reprezentacji danych poprzez opakowywanie argumentów 
we wskaźnik (ang. boxing). W tej pracy prezentuję, odmienne od standardowego,
podejście do implementacji częściowej aplikacji i polimorfizmu parametrycznego, 
które unika niepotrzebnego narzutu wydajnościowego. Zaimplementowałem kompilator 
języka funkcyjnego \textit{MonoML}, bazującego na języku F\#. 
Skupiając się na możliwe optymalnej implementacji najważniejszych cech języków 
z rodziny ML, zdecydowałem się na inne kompromisy niż popularne kompilatory. 
Zastosowałem monomorfizację, która pozwala na zmniejszenie narzutu pamięciowego 
związanego z implementacją funkcji polimorficznych, kosztem zwiększonego 
rozmiaru wynikowego programu i trudności przy tworzeniu przenośnych 
bibliotek.

Języki z rodziny ML zazwyczaj zawierają skomplikowany system modułów, jako 
główną cechę pozwalającą na modularyzację pisanych w nich programów.
\textit{Klasy typów}, choć spopularyzowane przez Haskella, pojawiają
się w nowych językach ogólnego zastosowania. Są prostsze w implementacji
i użyciu niż system modułów oraz umożliwiają pisanie skomplikowanych i modularnych 
programów, bez duplikowania kodu. Mimo to nieznany jest żaden 
popularny język z rodziny ML zawierający klasy typów, dlatego zdecydowałem się je 
zaimplementować w MonoMLu.

W dalszej części tego rozdziału przedstawię dokładniej cechy języków funkcyjnych, 
które zdecydowałem się zaimplementować oraz omówię czym jest infrastruktura LLVM. 
Drugi rozdział zawiera opis składni i semantyki języka MonoML oraz 
fragmenty przykładowych kodów. W trzecim rozdziale w szczegółach
prezentuję, w jaki sposób zaimplementowałem najistotniejsze cechy języka.
W czwartym rozdziale opisałem testowanie wydajności MonoMLa
na tle innych języków oraz pokazałem narzut opakowywania argumentów we wskaźnik.

% tych podstawowych cechach języków z rodziny ML. Ponadto 

\section{Efektywna implementacja języka funkcyjnego}

Istotnym celem tej pracy jest implementacja głównych cech języków funkcyjnych w
możliwie optymalny sposób. Skupię się na optymalizacji czasu wykonania 
programu kosztem rozmiaru wygenerowanego kodu. Kompilacja będzie się odbywać 
do kodu maszynowego, gdyż daje to lepszą wydajność otrzymanego programu. 
Stanowi to jednak duże wyzwanie przy kompilacji języka funkcyjnego ze względu 
na konieczność translacji abstrakcyjnych i wysokopoziomowych konstrukcji do 
języka niskiego poziomu. Uzyskanie 
podobnej lub lepszej wydajności niż popularne kompilatory języków funkcyjnych
jest trudne,
gdyż te stosują dużą liczbę skomplikowanych optymalizacji. Skupię się nad tym, 
aby moja implementacja prostego języka funkcyjnego, była porównywalna 
wydajnością 
z popularnymi rozwiązaniami bez dodatkowych optymalizacji. Omówię i porównam 
sposoby w jaki zdecydowałem się 
zaimplementować:
% podstawowe cechy języków funkcyjnych, a w szczególności 
częściową aplikację, zagnieżdżone funkcje, polimorfizm i klasy typów. Moje 
rozwiązania bazują na pomysłach z różnych języków programowania, w tym 
imperatywnych. 
% Wspomniane cechy omówię dokładniej, ponieważ odbiegają od 
% rozwiązań stosowanych w popularnych językach funkcyjnych.

\section{Infrastruktura LLVM}
% TODO: 
% 1. Co to jest? 

% 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

% 3. Jak działa kompilowanie do LLVM? 

% 4. Krótki opis high-ollvm 

W celu uproszczeniu konstrukcji nowego kompilatora i ułatwienia pracy z 
generowaniem niskopoziomowego kodu, 
zdecydowałem się skorzystać z infrastruktury LLVM \cite{llvm}. 
Jest to zbiór narzędzi i bibliotek wykorzystywanych przez wiele współczesnych 
kompilatorów. LLVM dostarcza kompilator LLVM IR, który jest niskopoziomowym 
językiem stworzonym na potrzeby pisania 
kompilatorów. Przykładowy program napisany w LLVM IR:

\renewcommand{\thelstlisting}{\thesection\arabic{lstlisting}}
% \lstset{language=llvm}
\begin{lstlisting}[frame=lines]
@.str = internal constant [14 x i8] c"hello, world\0A\00"
declare i32 @printf(i8*, ...)

define i32 @main(i32 %argc, i8** %argv) nounwind {
entry:
    %tmp1 = getelementptr [14 x i8], [14 x i8]* @.str, i32 0, i32 0
    %tmp2 = call i32 (i8*, ...) @printf( i8* %tmp1 ) nounwind
    ret i32 0
}
\end{lstlisting}

LLVM IR składa się przede wszystkim z: deklaracji i definicji funkcji
(procedur), zmiennych globalnych, podstawowych bloków, przypisań oraz 
wywołań funkcji. Podstawowe bloki kodu jak i funkcje nie 
mogą być zagnieżdżone. 

W moim kompilatorze nie generuję kodu LLVMa bezpośrednio, 
korzystam z oficjalnej biblioteki dla OCamla, 
udostępniającej interfejs potrzebny do tworzenia elementów wygenerowanego kodu. 
System LLVM 
jest odpowiedzialny za ostatni etap procesu kompilacji, zamianę kodu 
pośredniego (LLVM IR) 
na assembler. Cały kod jest w postaci Single Static Assignment. Oznacza to że, 
do jednej zmiennej (etykiety) można przypisać tylko jedno wyrażenie. 
Dzięki takiej formie kodu pośredniego, LLVM jest w 
stanie przeprowadzić na nim pewne optymalizacje, przed wygenerowaniem kodu 
maszynowego. 

% \subsection{Alternatywy}

% TODO: 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

\section{Let-polimorfizm}

Istnieją funkcje, których implementacja jest taka sama niezależenie od typu, dla
którego ją aplikujemy. Przykładowo funkcja obliczająca długość generycznej
listy nie zależy od typu elementów, które się w niej znajdują. 
Funkcja $map :: (a \rightarrow b) \rightarrow [a] \rightarrow [b]$
transformująca zawartość listy 
z użyciem podanej funkcji mapującej, także nie zależy od zawartości listy. Nie 
oznacza to jednak, że podana funkcja mapująca i lista mogą mieć dowolny typ. 
Funkcja mapująca $(a \rightarrow b)$ musi przyjmować taki sam typ, jaki 
znajduje się w liście. W statycznie typowanym języku kompilator musi mieć 
pewność, że taki warunek zachodzi. Aby uniknąć powielania kodu, w większości 
języków funkcyjnych występuje let polimorfizm. 

Dzięki let polimorfizmowi w definicji funkcji dany argument może 
mieć ogólny typ, jeśli nie został on ukonkretniony w jej ciele.
Wprowadzenie let polimorfizmu do języka wymaga nie tylko jego obsługi 
w procesie generowania kodu (kompilacji), ale też przy etapie inferencji typów.
Każdy inferowany typ musi być najbardziej ogólny. W swoim kompilatorze 
zaimplementowałem oba te elementy. 
% Omówię i porównam swoje rozwiązanie z rozwiązaniami występującymi w innych językach.

% TODO: Można rozszerzyć inferencje typów o let polimorfizm

\section{Rozwijanie funkcji oraz częściowa aplikacja}

Częściowa aplikacja występuje wtedy, gdy po zaaplikowaniu mniejszej liczby 
argumentów niż wynosi arność funkcji, otrzymujemy nową funkcję. Przykładowo 
dla funkcji $f: (A \times B \times C) \rightarrow D$ o arności $3$,
po częściowym zaaplikowaniu jej do pierwszego 
argumentu $a : A$ otrzymujemy funkcję $g : (B \times C) \rightarrow D$ o arność $2$.
Formalnie, w trakcie procesu częściowej aplikacji,
funkcja $f$ musiała zostać zamieniona na funkcję o typie
$A \rightarrow (B \times C) \rightarrow D$, aby następnie móc zaaplikować do niej 
argument $a : A$. Wartość $a$ musi być zapamiętana w środowisku nowo powstałej 
funkcji $g$.
W szczególności
dla dowolnego $b : B$ i $c : C$  musi zachodzić: $g(b, c) = f(a, b, c)$. 
% Funkcja $g$, która jest 
% częściowo zaaplikowaną funkcją $f$, musi zapamiętać zaaplikowane dotychczas 
% argumenty. 

Częściowa aplikacja jest spotykana nie tylko w językach funkcyjnych. 
Przykładowo biblioteka standardowa języka C++ dostarcza funkcję
$bind$ \cite{cpp_bind}, która pozwala na zaaplikowanie części argumentów
w dowolnej kolejności. 

Częściową aplikację można osiągnąć poprzez rozwinięcie funkcji (ang. currying) 
do wielu funkcji jednoargumentowych. Funkcja $f$ z powyższego przykładu 
w rozwiniętej
formie ma typ $f : A \rightarrow B \rightarrow C \rightarrow D$. Funkcje w 
takiej postaci, wspierają częściową aplikację bez użycia dodatkowych 
funkcjonalności języka (na przykład funkcji $bind$ w języku C++).
Na poniższym fragmencie kodu języka Javascript
znajduje się przykład wprowadzenia częściowo aplikowalnej funkcji 
poprzez jej rozwinięcie.

% \lstset{language=javascript}
\begin{lstlisting}[frame=lines]
var add = x => (y => x + y);
var add3 = add(3);

console.log(add3(12)); // 15
console.log(add(3)(12)); // 15
\end{lstlisting}

Javascript nie jest językiem funkcyjnym, a funkcje w nim zdefiniowane są w 
zwiniętej formie. Z tego powodu konieczne jest zastosowanie rozwlekłej składni,
takiej jak w ostatniej linii powyższego przykładu. Ta sama funkcja 
zdefiniowana w OCamlu wygląda następująco:

\begin{lstlisting}[frame=lines]
let add x y = x + y 
print_int (add 3 12)
\end{lstlisting}

Funkcja \texttt{add} w języku w OCaml jest już w postaci rozwiniętej, więc jej 
deklaracja i wywołanie mają bardziej atrakcyjną formę niż w poprzednim 
przykładzie. Dlatego zdecydowałem się ją zaimplementować.

W praktyce taka metoda realizacji częściowej aplikacji, jak pokazałem na 
przykładzie Javascriptu, byłaby niepotrzebnie nieefektywna. Efektywniejszy,
ale też i złożony sposób obsługi aplikacji częściowej, który zastosowałem w tym 
kompilatorze, zaprezentuję w sekcji $3.4$.

% // Co zrobiłem, po co, dlaczego
% // co to {let polymorphism, type class}
% \section{Język ML}
% 1. Dlaczego ML, jakie są inne języki ML
% 2. Bazowanie na $ F\# $

% \chapter{Cechy języka \textit{MonoML}}
% \subsection{Składnia}

% // Usunąć tytuły z listingów będących częścią narracji
% // Zdjęcia nie mogą się łamać
% // Poprawić numery listingów
% // Listingi i sekcje z wielkiej litery ?
%// Wszystko co do kodu czcionką textbf

\section{Klasy typów}
Większość języków z rodziny ML w celu lepszego ustrukturyzowania
programu stosuje system modułów. Pozwala on na podzielenie programu na 
niezależne~od~siebie funkcjonalności.
Klasy typów, których głównym celem jest wprowadzenie 
ad--hoc polimorfizmu do języka, mogą po części także spełnić to zadanie 
\cite{modules_vs_typeclasses}. 
Są obecne w językach takich jak Haskell, Scala\cite{scala_traits} czy Rust
\cite{rust_traits}. Fakt, że pojawiają się
w nowych językach ogólnego zastosowania, świadczy o ich atrakcyjności z punktu 
widzenia programisty. 
% Mimo to nieznane są żadne popularne języki ML korzystającego
% z tego rozwiązania. 
% Jedynym z celów tej pracy jest wprowadzenie klas typów do 
% prostego języka funkcyjnego, bazującego na podstawowych cechach rodziny ML. W tym 
% celu stworzyłem kompilator języka \textit{MonoML}, wymyślonego na potrzeby tej pracy.

% \subsection{Klasy typów}

Jako pierwsze pojawiły się w języku Haskell\cite{tc_wiki}. 
Początkowo zostały użyte w celu umożliwienia przeładowania operatorów 
arytmetycznych i równości. Od tego czasu
znaleziono dla nich więcej zastosowań w różnych językach programowania. W języku
Haskell, poza tym, że umożliwiają użycie przeładowanych funkcji i definiowania 
funkcjonalności wspólnej dla wielu typów (interfejsów), okazały się niezbędne 
do implementacji Monad. W języku systemowym Rust odpowiednikiem klas typów są
\textit{cechy} (ang. trait). W podstawowych użyciach nie różnią się od klas typów, ale 
nie pozwalają na implementacje polimorfizmu wyższych rzędów 
\cite{no_hkt_in_rust} (ang. 
Higher-rank polymorphism). Inną istotną różnicą jest fakt, że klasa typów z 
Haskella nie definiuje nowego typu, a jedynie pozwala na ograniczenie typu
polimorficznego do 
instancji klasy. \textit{Cecha} z Rusta może być użyta jak zwykły typ, przykładowo 
można stworzyć listę zawierające obiekty, które są różnymi instancjami 
(implementacjami) \textit{cechy} \cite{traits_as_obj_rust}. 
W Haskellu istnieją także rozszerzenia, które 
pozwalają na definicje klas z wieloma parametrami. 

% Jakich językach i czym się różnią

Istnieje wiele wariantów klas typów oraz rozwiązań do nich podobnych, dlatego w swoim 
kompilatorze zdecydowałem się zaimplementować ich najprostszą wersje z jednym 
parametrem, wprowadzając ad--hoc polimorfizm do języka.

Podstawowe użycie klas typów zaprezentuję na przykładzie Haskella. 
W celu stworzenia klasy typów $C$ dla typu ogólnego $a$, należy 
zdefiniować zbiór funkcji, które musi zawierać instancja tej klasy. Dla danego 
typu i klasy może istnieć co najwyżej jedna instancja. 
Definiujemy klasę \texttt{Eq} zawierającą dwa operatory:~$==$ oraz~$/=$.
% \lstset{language=llvm}
\begin{lstlisting}[frame=lines]
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
\end{lstlisting}

Powiemy, że typ ukonkretniony z \texttt{a} jest instancją klasy \texttt{Eq}, 
jeśli zawiera deklaracje obu funkcji z odpowiednimi typami. Przykładowa 
instancja dla typu \texttt{Bool}, mogłaby wyglądać następująco:

\begin{lstlisting}[frame=lines]
instance Eq Bool where
  True == True = True 
  False == False = True 
  _ == _ = False
  l /= r = not (l == r)
\end{lstlisting}

\chapter{Język MonoML}

\section{Inspiracja}
Składnia języka \textit{MonoML} jest w większości zapożyczona z języka F\#, należącego
do rodziny ML. Dzięki zastosowaniu składni czułej na wcięcia, która eliminuje 
konieczność użycia wielu słów kluczowych, jest jednym z prostszych, pod względem 
składni, języków z tej rodziny. Przy tworzeniu nowego języka funkcyjnego kierowałem się głównie 
jego prostotą. Poza zapożyczeniem składni F\# dla podstawowych wyrażeń,
funkcji i typów, rozszerzyłem ją o wyrażenia koniecznie do realizacji klas 
typów i ich instancji. Ich składnia została zaczerpnięta z Haskella.
% Jedną z najpopularniejszych funkcjonalności, zasugerowaną przez użytkowników, są
% typy klas \cite{fslang_typeclass}. 
% To było jedną inspiracją do całego projektu 
% i dodania tego elementu do jednego z 

Gramatyka w notacji \textit{EBNF} przedstawiona w poniższych sekcjach 
jest zbliżona do rzeczywistej składni języka.
Dokładny opis gramatyki znajduje się w pliku 
\path{monoml-compiler/compiler/parsing/grammar.mly}. Jest bardziej skomplikowany
ze względu na rozpoznawanie wciętych bloków kodu na
poziomie parsera. Lepszym pod względem czytelności gramatyki, 
jest wykonanie tej czynności na etapie lexera, tak jak to ma miejsce w F\#.
Dokładniejszy opis 
sposobu parsowania składni bazującej na wcięciach znajduje się w rozdziale 
\ref{wciecia_omowienie}. 

\section{Podstawowe wyrażania}

\subsection{Wyrażenia warunkowe}

Składnia i semantyka wyrażeń warunkowych jest bardzo podobna do tej w F\#. W 
języku MonoML
istnieją jednak pewne uproszczenia względem F\#. 
Warunek musi być prostym wyrażeniem zawierającym operacje arytmetyczne i 
logiczne lub wywołania funkcji. Nie może zawierać przykładowo:
wielolinijkowych wyrażeń \textit{if} i wyrażeń \textit{let}. 
Ciało warunku może być złożonym wyrażeniem, takim jak 
ciało funkcji, o ile występuje w nowej lini i jest wcięte bardziej niż 
token \textit{if}. Listingi $2.2.1$ i $2.2.2$ prezentują składnię wyrażeń 
warunkowych i przykład ich użycia w języku MonoML.
% TODO: Więcej o wcięciach

% \begin{lstlisting}[frame=lines, caption=Wyrażenia warunkowe.]
% <simple-if-exp> ::= if <simple-exp> 
%                       then <simple-exp> 
%                       <simple-elif-exp> 
%                       <simple-else-exp>
% \end{lstlisting}
\begin{lstlisting}[frame=single, caption=Wyrażenia warunkowe.]
  <simple-if-exp> ::= 
      if <simple-exp>  
      then <simple-exp> 
      <simple-elif-exp>? <simple-else-exp>?

  <if-exp> ::= 
      if <simple-exp> <newline>
      then 
      <body-exp>+ <elif-exp>* <else-exp>

  <simple-else-exp> ::=
      else <simple-exp> 

  <simple-elif-exp> ::=
      elif <simple-exp>
      then <simple-exp> 

  <elif-exp> ::=
      elif <body-exp>+ 
    | <simple-elif-exp> 

  <else-exp> ::=
      else <body-exp>+ 
    | <simple-else-exp> 
\end{lstlisting}

\begin{lstlisting}[frame=single, caption=Przykłady wyrażeń warunkowych.]
let isZero x = if x = 0 then true else false

let rec factorial x = 
    if x = 0 
    then 1 
    else x * factorial (x - 1)

let rec pow x n = 
    if (n = 0) && (x = 0)
    then 
      0 
    elif n = 0 
    then 
      one ()
    elif n = 1 
    then x
    else 
      mult x (pow x (n - 1))
\end{lstlisting}

\subsubsection{Sematyka wyrażeń warunkowych}
Wyrażenie w warunku musi mieć typ logiczny bool. Wszystkie gałęzie wynikowe
wyrażenia warunkowego muszą mieć taki sam typ. Jeśli typ wyrażenia po 
\texttt{then} 
to \texttt{unit}, przypadek \texttt{else} może zostać pominięty.
Jest to podejście znane z pozostałych języków z rodziny ML.

\subsection{Wyrażenia arytmetyczne i logiczne}
Wyrażenia arytmetyczne i logiczne mają taką samą składnię i semantykę
jak w pozostałych językach z rodziny ML. Obsługiwane są operatory $\$\$$, 
$||$, $=$, $+$, $-$, $*$, $/$, oraz pozostałe operatory porównywania. 
Operatory logiczne wymagają operandów o typie 
bool lub int i zwracają typ bool, a operatory arytmetyczne wymagają typów int. 
Operatory porównywania 
sprawdzają równość fizyczną zmiennych o tym samym typie.
Poniższy listing prezentuje gramatykę wyrażeń arytmetycznych i logicznych.

\begin{lstlisting}[frame=lines]
  <bool-exp> ::=
      <simple-exp> <bool-op> <simple-exp> 
  
  <arith-exp> ::=
      <simple-exp> <arith-op> <arith-exp> 
  
  <arith-op> ::=
      + | - | * | /
  
  <bool-op> ::=
      && | || | = | < | > | <= | >= 
\end{lstlisting}

Na kolejnym listingu znajdują się proste funkcje zawierające wyrażenia 
arytmetyczne i logiczne.

\begin{lstlisting}[frame=lines]
let isZero x = x = 0 
let add5 x = x + 5
let mod2 x = x - ((x / 2) * 2)
let alwaysTrue x = (mod2 x = 0) || (mod2 (x + 1) = 0)
\end{lstlisting}

\section{Deklaracja funkcji (wyrażenie let)}

Argumenty funkcji muszą być w tym samym wierszu co słowo \textit{let}. 
Po znaku~$=$ ciało funkcji może być złożonym wyrażeniem, o ile zaczyna się 
w~następnym wierszu i 
jest w~późniejszej kolumnie niż \textit{let}. Wyrażenie \textit{let} może być 
zdefiniowane w jednej linii, o ile jego ciało jest pojedynczym wyrażeniem prostym.
Standardowo dla języków z rodziny ML należy explicite zaznaczyć słowem 
kluczowym \textit{rec} jeśli funkcja jest rekurencyjna. Dodatkowo do argumentów
funkcji jak i jej wyniku można dodać adnotację typu.

\subsubsection{Semantyka wyrażeń let}

Typ wynikowy całego wyrażenia jest taki jak typ ostatniego wyrażenie w ciele 
let. Wyrażenie let wprowadza nowy symbol do środowiska, dostępny od momentu 
definicji. Typ wprowadzonego symbolu to $ a_1 \rightarrow ...\rightarrow a_n 
\rightarrow r $, gdzie $a_1, ..., a_n$ to typy kolejnych argumentów, a $r$ to 
typ ostatniego wyrażenia w ciele. Jeśli nie zostały zdefiniowane żadne argumenty 
to typ symbolu to $r$. W przypadku braku argumentów, ciało wyrażenia let 
jest ewaluowane gorliwie, przy uruchomieniu programu.

Poniższy listing zawiera przykłady wyrażeń let bez argumentów, 
z wielo- i jedno wierszowym ciałem.

\begin{lstlisting}[frame=lines]
let compose (f : 'b -> 'c) (g : 'a -> b) (x : 'a) : 'c = f (g x)

let printInt (x : int) : () = ll_putint x (* funkcja wewnętrzna *)

let adder a b = 
  printInt a 
  printInt b 

  a + b

let _ = 
    printnInt (120 * 120)
    printnInt (compose square factorial 5)
\end{lstlisting}


% TODO: Let z argumentami z adnotacjami.
% TODO: Rekurencja

% \begin{lstlisting}[frame=lines, caption=Wyrażenia warunkowe.]
%   <let-exp> ::=
%     { let <identifier}+ =}{simple-exp> 
%       \bnfor let <identifier}+ =}
%       <{ newline } <body-exp>
%     }\\
% \end{lstlisting}

\subsection{Wzajemnie rekurencyjne wyrażenia let}

Możliwe jest także zdefiniowanie globalnych (ang. top level) funkcji wzajemnie 
rekurencyjnych z użyciem słowa \textit{and}. Deklaracja pierwszej funkcji 
musi zaczynać się od \textit{let rec}, a kolejne od \textit{and}. Wzajemnie 
rekurencyjne funkcje mają dostęp do symboli zdefiniowanych w swojej grupie,
niezależnie od ich kolejności. Nie można zdefiniować wzajemnie rekurencyjnych 
wartości --- każde wyrażenie let rec musi definiować niezerową liczbę argumentów.

Poniższy fragment kodu zawiera dwie funkcje wzajemnie rekurencyjne.

\begin{lstlisting}[frame=lines]
let rec even x = 
    if x = 0
    then 0
    else odd (x - 1)
and odd x = 1 + (even (x - 1))
\end{lstlisting}

% \begin{grammar}
% \begin{lstlisting}
% % <expression> ::= ['$+$' | '$-$'] <term> \{('$+$' | '$-$' ) <term>\}

% % <term> ::= <factor>* \{('$*$' | '$/$') <factor>\}

% % <factor> ::= "number" | <identifier>  | '(' <expression> ')'
% \end{lstlisting}
% \end{grammar}

\section{Rekordy}

\subsection{Deklaracja rekordu}

Składnia rekordów jest podobna do tej z pozostałych języków z rodziny ML. 
Rekord zawiera wiele pól o różnych nazwach. Każde pole musi mieć zdefiniowany 
typ. Typem pola może być inny, wcześniej zadeklarowany, rekord.
Gramatyka deklaracji rekordów:
\begin{lstlisting}[frame=lines]
  <record-decl> ::=
      type <identifier> =
        { <field-decl}+ 
        }
  
  <field-decl> ::=
      <identifier> : <identifier>+ ( <newline> | ; )
\end{lstlisting}

Przykładowe deklaracje rekordów:
\begin{lstlisting}[frame=lines]
type simple  = { a : int; b : int    }
type complex = { n : int; s : simple }

type point3d = 
  { x : int 
    y : int; z : int 
  }
\end{lstlisting}

\subsection{Literał rekordu}

Literał może być zdefiniowany w jednym lub wielu wierszach. W przypadku 
definicji w jednym wierszu kolejne pola muszą być oddzielone średnikami. 
Średnik może być pominięty, jeśli kolejne pola są oddzielone nową linią. 
W definicji wielowierszowej klamra otwierająca i zamykająca muszą być w tej 
samej kolumnie. Typ wyrażeń podstawianych pod każde pole musi zgadzać się ze 
zdefiniowanym typem dla danego pola. 
Gramatyka literału rekordu:
\begin{lstlisting}[frame=lines]
<record-lit> ::=
      { <field-lit}+
      }

<field-lit> ::=
      <identifier} = <simple-exp> (<newline> | ; )
\end{lstlisting}
\pagebreak
Przykładowe literały rekordu:

\begin{lstlisting}[frame=lines]
let s : simple = { a = 0; b = 1}

let p3 : point3 = 
  { x = 10
    y = 1000000 
    z = -10 
  }
\end{lstlisting}

\subsection{Uaktualnianie rekordu}

Rekordy w MonoMLu, podobnie jak rekordy w F\# i OCamlu, 
są trwałe. 
Uaktualnienie jednego z pól skutkuje stworzeniem nowego rekordu i nie zmienia 
wartości któregokolwiek z pól z pierwotnej instancji. 
Typ wyrażenia, które uaktualniana dane pole musi być taki sam jak typ pola 
w deklaracji rekordu.
% Dlatego to
% wyrażenie ma inną składnię niż ta znana z języków imperatywnych.
Gramatyka uaktualniania rekordu:
\begin{lstlisting}[frame=lines]
<record-update> ::=
      { <simple-exp>  with 
        <field-update}+ 
      }

<field-update> ::=
      <identifier} = <simple-exp> (<newline> | ; )
\end{lstlisting}
% TODO: samo pole 

Poniższy fragment kodu zawiera deklarację, literał i uaktualnienie rekordu.

\begin{lstlisting}[frame=lines]
type simple  = { a : int; b : int    }
type complex = { n : int; s : simple }

let s : simple = { a = 0; b = 1}

let add (curr : complex) = 
    {  curr.s with a = curr.s.b
                    b = curr.s.a + curr.s.b 
    }
\end{lstlisting}

\textbf{Uwaga.} Przy przekazywaniu rekordu jako argument, należy dodać 
adnotację typu do argumentu. W obecnej implementacji typy rekordów nie są 
inferowane.

\section{Klasy typów}

Jako że w językach z rodziny ML nie występują klasy typów, ich składnię
zdecydowałem się zapożyczyć z Haskella.

\subsection{Deklaracja klasy}

Deklaracja 
definiuje typ ogólny, który może być użyty w definicji metod klasy.
Metody klasy muszą być funkcjami --- nie mogą być wartościami. Obecna implementacja
nie wspiera metod klasy, które muszą być ewaluowane przy uruchomieniu programu, 
ale nie ma przeszkód utrudniających ich dodanie.
Poniższy fragment kodu prezentuje przykładowe deklaracje 
klas \texttt{Print} i \texttt{Pow}.

\begin{lstlisting}[frame=lines]
class Print 'a where 
    print : 'a -> ()
  
class Pow 'a where 
    one  : () -> 'a
    mult : 'a -> 'a -> 'a
\end{lstlisting}

\subsection{Deklaracja instancji}

Instancja klasy musi zawierać nazwę klasy, którą implementuje oraz typ konkretny,
dla którego tworzona jest instancja. Typ zadeklarowanych metod w
instancji klasy musi być zgodny z typami w definicji danej metody z klasy,
przy założeniu, że typ generyczny został podmieniony z typem konkretnym. 

Instancje klas dla różnych typów konkretnych 
mogą być zaimplementowane w sposób następujący:

\begin{lstlisting}[frame=lines]
instance Pow int where
    let one () = 1 
    let mult x y = x * y

instance Print int where 
    let print x = printInt x 

instance Print Vec where 
    let print (v : Vec) = 
        printInt v.x 
        printSpace ()
        printInt v.y
\end{lstlisting}

\section{Moduły}

Moduły w MonoMLu spełniają takie zadanie jak te w F\# --- służą jako 
przestrzeń nazw dla związanych ze sobą definicji. Nie są odpowiednikiem 
dużo bardziej zaawansowanych modułów SMLa czy OCamla.
Moduł zawiera: wyrażenia let, zagnieżdżone moduły, import innych 
modułów oraz deklaracje funkcji zewnętrznych. Nazwa modułu musi się zaczynać 
wielką litery. 

Otwarcie modułu powoduje wprowadzenie zawartych w nim symboli do 
lokalnej przestrzeni nazw. Przykład modułów z definicjami 
i otwieranie modułów:

\begin{lstlisting}[frame=lines]
module Prelude = 
    module Internal = 
        external ll_putint      : int -> () 
        external ll_print_bool  : bool -> () 
        external ll_print_line  : ()  -> () 
        external ll_print_space : ()  -> () 

    let printInt x = Internal.ll_putint x

    open Internal 
    
    let printNl = ll_print_line
    let printSpace = ll_print_space
    let printBool b = ll_print_bool b

open Prelude
open Prelude.Internal
\end{lstlisting}

% TODO: Gramatyka modułu

\section{Tablice}

Zaimplementowane zostały jedynie tablice zawierające typ \texttt{int}. 
Tablice są ulotną strukturą danych. Na poziomie języka można
 stworzyć literał 
tablicy. Zmiana i odczytanie komórki tablicy bądź utworzenie niezainicjalizowanej 
tablicy odbywa się poprzez zewnętrzne funkcje zaimplementowane w C. 
Tablice w MonoMLu są reprezentowane tak samo, jak języku w C --- jako spójny
ciąg w pamięci.

Elementami literału tablicy mogą być literały liczbowe oddzielone średnikiem. 
Podobnie jak w OCamlu i F\# tablica zaczyna się od symbolu~$[|$, a 
kończy symbolem~$|]$.

\textbf{Uwaga.} Dla wielowierszowego literału tablicy symbole rozpoczynający 
$[|$ i kończący $|]$ muszą być w tej samej kolumnie.

\pagebreak
Przykład jedno i wielo wierszowego literału:
\begin{lstlisting}[frame=lines]
let arr : int array = [| 1; 1; 2; 3; 5 |]

let multiLineArr : int array = 
  [|1; 2;
    3
    4
  |]
\end{lstlisting}

\section{Wołanie funkcji z C}

Mała część funkcjonalności języka została zaimplementowana z użyciem 
zewnętrznych funkcji w C (wypisywanie oraz operacje na tablicy). Dlatego 
koniecznym było dołożenie wyrażeń, pozwalających zadeklarować zewnętrzny symbol 
wraz z jego typem. Ich składnia jest prawie taka sama jak w OCamlu.
Typy MonoMLa są dosłownie tłumaczone na typy z C z wyjątkiem typu \texttt{unit}, 
który jest zamieniany na \texttt{bool} (o rozmiarze jednego bajtu).

Przykładowo definicja zewnętrznego symbolu, o sygnaturze w C \newline 
\texttt{void set\_array\_elem(int* arr, int i, int val)}, wygląda następująco: 

\begin{lstlisting}[frame=lines]
external set_array_elem : int array -> int -> int -> () 
\end{lstlisting}



% TODO: Gramatyka external

% 1. Opis, szczegóły składni, (przykłady: każda cecha języka i krótki przykład)

% 1. Proste wyrażenia, rekurencja, let-polymorphism, rekordy,
% wzajemnie rekurencyjne funkcje na top levelu, klasy typów, proste moduły, 
% wyrażanie na top levelu, efekty uboczne, inferencja typów, anotacje.

% % \section{Klasy typów}

% 1. Wprowadzenie czym są 

% 2. Dlaczego? Jakie są alternatywy

% 3. Opis tego co zostało zaimplementowane, porównanie do innych języków, (Haskell,
% Rust, Scala)

\chapter{Kompilator}
\section{Etapy kompilacji}

Cały proces kompilacji, od momentu wczytania pliku z kodem źródłowym do 
wyprodukowania pliku wykonywalnego, składa się z następujących etapów:
\begin{enumerate}
  \item Analiza leksykalna, w efekcie której otrzymujemy ciąg tokenów. 
  Implementacja w pliku: 
  \path{monoml-compiler/compiler/parsing/lexer.cppo.sedlex.ml}

  \item Otrzymany ciąg jest następnie poddany analizie składniowej 
  (ang. parsing), która zgodnie z podaną gramatyką generuje \textit{drzewo 
  składni abstrakcyjnej (ang. abstract syntax tree)}. Węzły tego drzewa 
  zawierają jedno z wyrażeń języka, 
  lecz nie posiadają informacji o jego typie. 
  Implementacja w pliku: \newline
  \path{monoml-compiler/compiler/parsing/grammar.mly}
 
  \item Następnie wykonywana jest transformacja drzewa składni, która:

  \begin{enumerate}
    \item Dzięki przeprowadzeniu inferencji typów, nadaje każdemu wyrażeniu jego typ z języka MonoML (na późniejszym etapie, wyrażenia będą miał typ 
    z LLVM IR). 
    \item Eliminuje zagnieżdżone wyrażenia \textit{let}.
    \item Eliminuje moduły oraz otwarcia modułów poprzez translacje symboli do 
    ich w pełni kwalifikowanych nazw (ang. fully qualified name).
  \end{enumerate}
  Implementacja w pliku: 
  \path{monoml-compiler/compiler/typed_ast.ml}

  \item Generowanie drzewa wyrażeń z LLVM IR. Jest to największy etap z całego 
  procesu kompilacji. Zamienia skomplikowane wyrażenia wysokopoziomowego języka
  na proste wyrażenia LLVM IR, które już łatwo mogą być przetłumaczone na 
  niskopoziomowe instrukcje.
  Implementacja w pliku: 
  \path{monoml-compiler/compiler/codegen.ml}

  \item Konwersja drzewa wyrażeń LLVM IR na kod LLVM IR. Odbywa się to dzięki 
  interfejsowi programistycznemu (ang. api), udostępnionemu przez oficjalną 
  bibliotekę LLVM dla OCamla \cite{llvm_in_ocaml}.

\end{enumerate}

% 1. Jakie są etapy (lexer $\rightarrow$ parser $\rightarrow$ untyped ast 
% $\rightarrow$ 
% typed ast bez zagnieżdżonych funkcji $\rightarrow$ generowanie kodu (ast 
% high-ollvm)
% $\rightarrow$ wywoływanie funkcji z api llvma $\rightarrow$ llc 
% $\rightarrow$ gcc i 
% sexternal) 

% 2. Krótko o każdym etapie

\section{Analiza leksykalna}

Do przeprowadzania analizy leksykalnej skorzystałem z biblioteki 
\textit{sedlex}. Jest to generator lekserów dla języka OCaml.

\subsection{Analiza wcięć} \label{wciecia_omowienie}
 
Istnieje wiele języków programowania realizujących ideę składni czułej na 
wcięcia. Sposób w jaki działa to w F\# jest jednym z bardziej zaawansowanych,
bo pozwala na zdefiniowanie wielowierszowych aplikacji funkcji, warunków itp. 
bez użycia znaków przełamania wiersza bądź słów kluczowych znanych 
z języka OCaml (\texttt{begin}, \texttt{end}, \texttt{;}, \texttt{in}).
 W F\# 
istnieje 
także możliwość mieszania tych słów kluczowych z wcięciami. 

Analiza wcięć w MonoMLu jest zbliżona do tej w Pythonie
\cite{python_indentation}. Dla każdego wiersza
na bieżąco jest obliczany numer kolumny pierwszego znaku (wcięcie). Długości 
wcięć z poprzednich wierszy są trzymane na stosie. Na początku na stosie
znajduje się wcięcie długości $0$. Gdy wcięcie w obecnym wierszu jest większe od 
ostatniego na stosie, generowany jest token \textit{INDENT} oznaczający 
początek wciętego bloku. Gdy wcięcie jest mniejsze od ostatniego na stosie, 
wszystkie większe wcięcia są zdejmowane ze stosu i dla każdego zdjętego wcięcia 
generowany jest token \textit{DEDENT}. Oznacza on koniec wciętego bloku. 
Po zdjęciu 
wszystkich większych wcięć, ostatnie wcięcie, które zostanie na stosie, musi być 
równe wcięciu z obecnie przetwarzanego wiersza, a w szczególności może być równe $0$. 
W przeciwnym 
przypadku kod źródłowy jest źle wcięty i kompilator zwróci błąd.

\section{Parsowanie}

Popularnym narzędziem do generowania parserów jest \textit{Menhir} 
\cite{menhir}. Na podstawie podanej gramatyki \textit{LR(1)}, generuje kod OCamla, 
który ją parsuje. Częściowo wspiera składnię \textit{EBNF}, m. in. operatory: $
+$, $?$, $\ast$. Zdecydowałem się skorzystać z tego narzędzia ze względu na 
łatwość użycia, możliwość interaktywnego debugowania gramatyki oraz 
ekspresywność składni w porównaniu do podobnych narzędzi takich jak \textit
{ocamlyacc} \cite{menhir}. Całość gramatyki znajduje się w pliku \newline
\path{monoml-compiler/compiler/parsing/grammar.mly}. 
% TODO: Może coś o kontekstach w F\#

% \section{Generowanie kodu}
\section{Częściowa aplikacja i funkcje}

Jak wspomniałem we wprowadzeniu, generowanie wszystkich funkcji w rozwiniętej 
formie (każda funkcja przyjmuje tylko jeden argument) jest nieoptymalne pod
względem rozmiaru kodu, jak i szybkości jego wykonania. Pomimo że aplikacja 
częściowa jest bardzo przydatną cechą języków funkcyjnych, to często funkcje
wywoływane są ze wszystkimi argumentami. W takich przypadkach chcielibyśmy 
korzystać z wywołania funkcji, które jest tak szybkie, jak w C. 
W kompilatorze MonoMLa pracowałem nad rozwiązaniem, które w pozostałych 
przypadkach korzystałoby z przekazywania argumentów funkcji przez rejestry i 
pozwalałoby na przekazywanie typów danych, o różnych rozmiarach, przez ich 
wartość (bez opakowywania we wskaźnik). 

\subsection{Opis działania}

Podzielmy wszystkie wywołania funkcji na dwie grupy. Wywołania do znanych 
(ang. known call) i nie znanych funkcji (ang. unknown call). Znane funkcje to 
takie, których definicję można łatwo wskazać na etapie kompilacji. 

W następującym fragmencie kodu wywołana funkcja \texttt{double} jest 
statycznie znana.

\begin{lstlisting}[frame=lines] 
let double x = x + x
let main = 
  printInt (double 4)
\end{lstlisting}

Przykładem nieznanych funkcji są funkcje, które: 
\begin{itemize}
  \item zostały podane jako argument,
  \item są wynikiem wywołania funkcji,
  \item są wynikiem częściowej aplikacji funkcji.
\end{itemize}

Na poniższym fragmencie wywołane funkcje \texttt{a}, \texttt{b} i \texttt{c} 
są nieznane.

\begin{lstlisting}[frame=lines]
let getIdentity () = 
  let id x = x 
  id

let apply f x = f x

let main (b : 'a -> 'a) = 
  let c = apply b 
  let a = getIdentity ()
  (a 1 = b 1) && (b 1 = c 1)
\end{lstlisting}

\subsubsection{Wywołanie funkcji znanej}

Gdy funkcja, którą chcemy wywołać, jest znana, możemy wyróżnić trzy przypadki 
ze względu na liczbę argumentów w aplikacji względem liczby argumentów
w definicji funkcji.

\begin{enumerate}
  \item Liczba argumentów z aplikacji jest mniejsza od liczby zdefiniowanych 
  argumentów. W tym przypadku utworzony zostaje obiekt reprezentujący częściowo
  zaaplikowaną funkcję. Zostaną w nim zapisane argumenty z aplikacji
  oraz 
  wskaźnik na odpowiednią funkcję. Skopiowane argumenty i sam obiekt 
  zostaną 
  utworzone na stercie.
  \item Argumentów z aplikacji jest tyle samo co zdefiniowanych. 
  Funkcja zostanie wywołana w stylu z C. Jest to optymalny 
  przypadek wywołania funkcji i nie powoduje on zaalokowania żadnej 
  dodatkowej pamięci. 
  Jeśli początkowe argumenty mieszczą się w rejestrach, to mogą zostać 
  przez nie przekazane.
  \item Argumentów z aplikacji może być więcej niż zdefiniowanych, 
  jeśli wynikiem wywoływanej funkcji jest funkcja. Niech $k$ będzie 
  liczbą argumentów w definicji funkcji, a $n$ liczbą 
  argumentów z aplikacji, gdzie $n > k$. Najpierw nastąpi wywołanie znanej 
  funkcji z pierwszymi $k$ argumentami. Wynik pierwszego wywołania, 
  który teraz jest nieznaną funkcją, zostanie zaaplikowany do pozostałych
  $n - k$ argumentów. W tym momencie 
  zastosowany zostanie jeden z przypadków dla wywołań nieznanych funkcji.

% TODO: Coś o tym że funkcje / symbole trzymane są w środowisku z informacją 
% known / unknown.
\end{enumerate}

\subsubsection{Wywołanie funkcji nieznanej}

Wywołania funkcji nieznanych podzielimy na takie, których wynikiem jest dowolna
funkcja $ a \rightarrow b $ i takie, których wynikiem jest wartość. Podczas
fazy inferencji typów obliczany jest typ każdego wyrażenia, więc kompilator
jest w stanie określić, do której grupy należy dana aplikacja funkcji. Każda 
nieznana lub częściowo zaaplikowana funkcja jest reprezentowana przez strukturę 
(taką jak w C), 
zawierającą następujące pola:

\begin{itemize}
  \item wskaźnik na funkcję,
  \item wskaźnik na środowisko --- zapamiętane argumenty, które są pamiętane 
  jako spójny ciąg bajów (dynamicznie zaalokowana tablica z C),
  % TODO: Można też tablice wskaźników na argumenty i 
  % dlaczego tak nie zrobiłem
  \item pozostała liczba argumentów do wywołania wskazywanej funkcji,
  \item arność funkcji,
  \item liczba bajtów w środowisku.
\end{itemize}

% \pagebreak
Definicja takiej struktury w C wyglądałaby następująco.

\begin{lstlisting}[frame=lines]
struct function {
    void (*fn)();
    unsigned char *args;
    unsigned char left_args;
    unsigned char arity;
    int used_bytes;   
};
\end{lstlisting}

Wskaźnik na funkcję \texttt{fn} przed wywołaniem musi zostać zrzutowany na 
prawidłowy typ. Dla aplikacji funkcji, których wynikiem jest funkcja, typ 
wynikowy wygenerowanej funkcji \texttt{fn} to struktura \texttt{function}. 
Jako argumenty 
funkcji \texttt{fn}, poza argumentami podanymi w aplikacji funkcji, przekazane 
zostaną dodatkowo: wskaźnik na środowisko i liczba argumentów w aplikacji.
Funkcja wołana jest odpowiedzialna za nadmiarowe argumenty i przekazanie ich 
dalej.

Aplikacja funkcji nie zawsze musi się wiązać z faktycznym wywołaniem funkcji.
Na poniższym przykładzie w ciele funkcji \texttt{apply},
w pierwszym przypadku funkcja \texttt{f} zostanie wywołana, 
a w drugim, pomimo aplikacji funkcji o tym samym typie do tych samych 
argumentów, nic nie zostanie wywołane.

\begin{lstlisting}[frame=lines]
let called a b = 
  let inner c d = a + b + c + d in 
  print_string "called\n";
  inner 

let not_called a b c d = a + b + c + d 

let apply f a b c : int -> int = 
    f a b c 

let _ = 
    apply called 1 2 3;
    apply not_called 1 2 3
\end{lstlisting}
% TODO: Przykład z wywołaniem i nie wywołaniem częściowo 
% zaaplikowanej funkcji  

Dla każdego wywołania nieznanej funkcji generowany jest dodatkowy
kod, który jest odpowiedzialny za sprawdzenie, czy aplikowaną funkcje 
faktycznie trzeba wywołać, czy jedynie zapisać dodatkowe argumenty do 
środowiska. Aby to sprawdzić, porównywana jest liczba argumentów pozostałych do 
wywołania funkcji (\texttt{left\_args}) z liczbą argumentów, do których 
funkcja jest aplikowana.
Jeśli liczba pozostałych argumentów jest większa, to wszystkie argumenty 
zostaną skopiowane do pola \texttt{args} w strukturze \texttt{function}, a 
odpowiednie jej pola uaktualnione.

% TODO: o dynamicznych przypadkach

% TODO: wywoływanie funkcji, przypadki z przykładami
% TODO: Przykład w pseudokodzie? Może algorytm

% TODO: Co to unknown i know call 

% TODO: generowanie każdej funkcji


% 1. Dlaczego jest to nietrywialne

% 2. Jakie miałem cele 

% 3. Jak to działa u mnie 

% 4. Przykład (wygenerowanego pseudo-kodu)

\subsubsection{Generowanie funkcji}

Jednym z założeń implementacji MonoMLa, była możliwość przekazywania typów
o różnym rozmiarze przez ich wartość, a nie przez wskaźnik. W obecnej 
implementacji istnieje tylko kilka typów o różnym rozmiarze: bool,
int i rekord. Rekordy mają taki sam rozmiar, ponieważ są 
przekazywane przez wskaźnik do ich zawartości zapamiętanej na stercie, ale 
łatwo rozszerzyć język o typy o dowolnej wielkości. 

Takie założenie komplikuje implementację częściowej aplikacji funkcji. Aby 
zrozumieć dlaczego, weźmy dwie instancje struktury \texttt{function} dla 
funkcji o typie \newline int $\rightarrow$ bool $\rightarrow$ int 
$\rightarrow$ bool. Niech pierwsza zostanie częściowo zaaplikowana do dwóch 
argumentów o typach int i bool, a druga do jednego argumentu
o typie int. W kolejnym kroku, chcąc wywołać obie funkcje, 
pierwszą strukturę aplikujemy do pozostałego argumentu o typie int, a
drugą do pozostałych dwóch o typach bool i int. Wskaźnik 
\texttt {fn} z pierwszej struktury zostałby zrzutowany na wskaźnik na funkcję 
przyjmującą jako pierwszy argument zmienną typu int, a funkcja 
wskazywana przez \texttt{fn} z drugiej struktury przyjmowałaby jako pierwszy 
argument typ bool. Nie można dopuścić do takiej sytuacji. Nasuwa się 
możliwe rozwiązanie, w którym w momencie, gdy dochodzi do wywołania funkcji (co 
może być sprawdzone w czasie działania programu dzięki polu 
\texttt{left\_args}) można przekazać wszystkie argumenty znajdujące się w 
środowisku. Wtedy typ funkcji wskazywanych przez \texttt{fn} po zrzutowaniu byłby 
taki sam, niezależnie od tego do ilu dotychczas argumentów zostały zaaplikowane.
Jednak argumenty w środowisku są zapamiętane przez wartość w tablicy \texttt
{args}, a ich reprezentacja nie jest jednorodna (mogą mieć różny rozmiar),
co uniemożliwia ich przekazanie.
Jednorodną reprezentację wszystkich argumentów można uzyskać poprzez 
reprezentowanie ich przez wskaźnik, ale takiego rozwiązania chciałem uniknąć.
Innym sposobem byłoby zapamiętanie wszystkich argumentów, także tych,
do których funkcja jest aplikowana na końcu, w środowisku. 
Wywoływana funkcja wie już w czasie 
kompilacji jakich argumentów (i o jakim rozmiarze), spodziewać się w środowisku,
więc jest w stanie je z niego odzyskać. To rozwiązuje wspomniany 
problem, lecz wykonuje niepotrzebne zapisywanie i ładowanie argumentów 
przy ostatniej aplikacji. Moje rozwiązanie unika tej operacji. 

W tym celu, poza generowaniem właściwej funkcji, generowane są także funkcje 
wejściowe (ang. entry point), które będą używane w przypadku wywoływania 
nieznanej funkcji. 
Funkcja wejściowa przyjmuje: 
\begin{itemize}
  \item wskaźnik na środowisko \texttt{unsigned char$\ast$},
  \item liczbę przekazywanych argumentów \texttt{unsigned char} 
  (obsługiwane jest maksymalnie 255 argumentów),
  \item część argumentów oryginalnej funkcji.
\end{itemize}
Załóżmy, że oryginalna funkcja ma typ: $a_1 \rightarrow a_2 \rightarrow ...
\rightarrow a_n \rightarrow t$. Wtedy, dla takiej funkcji zostanie wygenerowanych $n$ funkcji 
wejściowych, gdzie $i-ta$ funkcja będzie przyjmowała sufiks ciągu oryginalnych
argumentów, od $i-tego$ argumentu. Jeśli wynikiem oryginalnej funkcji jest 
funkcja, to argumenty funkcji wynikowej także będą uwzględnione w funkcji wejściowej.

Dla oryginalnej funkcji tworzona jest globalna tablica wskaźników na wszystkie 
jej funkcje wejściowe. Funkcje są zapamiętane w kolejności malejących prefiksów.
% , tj. 
% wskaźnik na pierwszą funkcję wejściową jest pierwszym elementem tablicy, na 
% drugą, drugim itd. 
Gdy tworzona jest instancja struktury \texttt{function}, jako wskaźnik na 
funkcję do wywołania ustawiany jest wskaźnik na początek tablicy funkcji 
wejściowych. Oznacza to, że typ pola \texttt{fn} w języku C to 
\texttt{void ($\ast\ast$fn)()}, oraz że przed wywołaniem funkcji ze struktury,
należy zdereferować (ang. dereference) wskaźnik. Wskaźnik na wołaną funkcją 
musi być w każdym momencie programu aktualny --- musi odpowiadać liczbie 
początkowych argumentów zapamiętanych w środowisku. Dlatego, gdy 
funkcja jest aplikowana do kolejnych argumentów, wskaźnik jest zwiększany. 

% \subsubsection{Funkcje wejściowe}
% TODO: Ciało funkcji wejściowych

Funkcje wejściowe są odpowiedzialne za odczytanie argumentów ze środowiska i 
przekazanie ich do wywołania oryginalnej funkcji. Jeśli wynikiem funkcji 
oryginalnej jest funkcja, następuje jeden z dwóch przypadków sprawdzanych w
czasie działania programu.

\begin{enumerate}
  \item Nie pozostały żadne argumenty do aplikacji ---
  funkcja wejściowa jako swój wynik może zwrócić wynik funkcji oryginalnej.
  \item Pozostałych argumentów jest mniej lub tyle samo niż wynosi 
  wartość pola \texttt{left\_args} ze struktury otrzymanej jako wynik 
  pierwszego wywołania.
  Należy zapisać pozostałe argumenty do środowiska i uaktualnić pola struktury 
  \texttt{function}.
\end{enumerate}

Po wywołaniu funkcji należy jeszcze sprawdzić, czy nie została zwrócona 
struktura, którą od razu można wywołać 
(taka, która ma pole \texttt{left\_args} 
równe $0$). Taki wynik mógł powstać w funkcji wołanej w drugim przypadku.

\subsection{Porównanie z innymi implementacjami}

Istnieję dwa modele realizacji częściowej aplikacji: push/enter i eval/apply. 
Zostały dokładnie opisane przez Marlow i Peyton Jones\cite{fast_curry}. 
Ich zasadnicza różnica polega na sposobie działania przy aplikacji funkcji 
nieznanej. W push/enter przed właściwym wywołaniem funkcji jej argumenty są 
ładowane na stos. Następnie to funkcja wołana jest odpowiedzialna za
rozważenie wszystkich przypadków związanych z liczbą argumentów w aplikacji.
Podejmuje decyzje o wywołaniu właściwiej funkcji i ewentualnym przekazaniu 
pozostałych argumentów dalej bądź zwróceniu obiektu reprezentującego częściowo
zaaplikowaną funkcję. W modelu eval/apply, to po stronie funkcji wołającej 
leży zadanie rozważania tych przypadków. Strona wołająca (ang. call site)
zna liczbę argumentów z aplikacji, a w czasie działania sprawdza 
właściwą arność funkcji. 

Moje rozwiązanie istotnie czerpie z modelu push/enter. Większość decyzji
jest podejmowana po stronie funkcji wołanej. Strona wołająca przekazuje 
wszystkie argumenty do funkcji wskazywanej w strukturze \texttt{function}. 
Jednak zanim to się stanie, to strona wołająca dynamicznie sprawdza arność 
funkcji. W przypadku gdy jest ona większa od liczby argumentów z aplikacji, 
to w tym miejscu uaktualniany jest obiekt częściowej aplikacji, oszczędzając 
na zbędnym wywołaniu funkcji. Jest to podobne do rozwiązania z enter/apply.
Strona wołająca nie musi także dynamicznie przeszukiwać stosu w poszukiwaniu 
przekazanych argumentów. Dzięki generowaniu wielu funkcji wejściowych funkcja 
wołana wie dokładnie ile argumentów i o jakim typie jest w środowisku, a jakie 
zostały właśnie przekazane. 

% // cite z bibliografii zamiast tytuły
Marlow i Peyton Jones \cite{fast_curry} jasno zalecają korzystanie z 
modelu eval/apply ze względu na 
prostszą implementację i trudności w kompilacji push/enter do przenośnego 
języka takiego jak C, C-{}- czy LLVM. Wspomniana trudność wynika z 
konieczności manualnego zarządzania stosem, co nie jest łatwe (o ile możliwe) 
w takich językach. Jednak moje rozwiązanie unika tego problemu, a ponadto
w takich językach. Jednak moje rozwiązanie unika tego problemu, a ponadto
umożliwia przekazywanie argumentów przez rejestry, co zostało wykluczone dla 
modelu push/enter. Te cechy zostały osiągnięte dzięki generowaniu wielu funkcji 
wejściowych, dla każdego sufiksu argumentów z typu funkcji. Niesie to ze sobą 
jednak istotną wadę, nieobecną w żadnym z dwóch wspomnianych modeli --- 
generowanie dużej ilości dodatkowego kodu. Nie jest to problemem dla małych 
przykładowych programów, jednak mogłoby znacznie zwiększyć czas kompilacji i 
rozmiar wynikowego programu przy dużych, profesjonalnych projektach.

% Porównanie z pracą "Making a fast curry: ..."

\section{Zagnieżdżone funkcje}

Zagnieżdżone funkcje są nieodłączną częścią języków funkcyjnych. Ich implementacja wykorzystuje 
\textit{closure conversion}, które zostało już użyte przy częściowej aplikacji funkcji. 
Ideą \textit{closure conversion} jest pamiętanie funkcji wraz z jej domknięciem. 
\textit{Closure conversion} dodaje duży narzut pamięciowy i czasowy na wygenerowany program,
dlatego należy ustalić dlaczego taka transformacja jest potrzebna.

Zdefiniujmy funkcję \texttt{make\_adder} w OCamlu, która będzie zwracać 
zagnieżdżoną funkcję.
Ciało zagnieżdżonej funkcji \texttt{add} odwołuje się do zmiennej z 
zewnętrznego zakresu.
% \pagebreak
\begin{lstlisting}[frame=lines]
let make_adder x = let add y = x + y in add 
  
let _ = let add1 = make_adder 1 in 
         let add5 = make_adder 5 in 
     
         print_int (add1 1);
         print_int (add5 5) 
\end{lstlisting}
Powyższy kod wypisze wynik działań $1 + 1$ oraz $5 + 5$. 

Niskopoziomowy język, taki jaki LLVM IR nie obsługuje zagnieżdżonych 
funkcji. Można w
nim zadeklarować jedynie procedury na takim samym, globalnym poziomie (ang. 
top level). 
Konieczna jest transformacja wyrażeń let, polegająca na przeniesieniu 
ich na globalny poziom. 
Jeśli wykonamy taką transformację na funkcji \texttt{add}, bez dodatkowych 
zmian, to zmienna $x$
przestanie być dostępna z ciała funkcji.

\begin{lstlisting}[frame=lines]
let add y = x + y 
let make_adder x = add 
\end{lstlisting}
Powyższy kody nie jest poprawnym programem w języku OCaml, oraz 
nie mógłby zostać poprawnie przetłumaczony na kod LLVM IR. 
Skoro \texttt{x} jest poza zasięgiem ciała \texttt{add}, można zaproponować rozwiązanie,
w którym wprowadzona zostaje globalna zmienna odpowiadająca zmiennej wolnej 
\texttt{x}, tak jak na poniższym fragmencie kodu.

\begin{lstlisting}[frame=lines]
let global_x = ref 0

let add y = !x + y 
let make_adder x = 
    global_x := x
    add 
\end{lstlisting}
Powyższe przekształcenia nie wprowadzają dużego narzutu na wynikowy program i rozwiązują 
problem z zasięgiem symbolu $x$. Ten kod jednak nie zwróci poprawnego wyniku, 
przy założeniu o statycznym zasięgu widoczności (ang. static scoping). Drugie 
wywołanie \texttt{make\_adder} dla argumentu 5 nadpisze jego pierwszą wartość, 
z której korzysta pierwsze wywołanie funkcji \texttt{add1}. 
Koniecznym jest zapamiętanie $x$ w środowisku funkcji 
\texttt{add}, w momencie, w którym jest zwracana. 

W MonoMLu, do implementacji \textit{closure conversion} postanowiłem wykorzystać,
już zaimplementowaną częściową aplikację. W czasie analizy programu dla każdego 
zagnieżdżonego wyrażenia let wyznaczam jego zmienne wolne. Zmienne wolne
zostaną dodane jako dodatkowe argumenty, przed tymi podanymi pierwotnie.
Następnie symbol, pod którym wyrażenie let było zapamiętane w 
środowisku, zostaje związany z częściową aplikacją oryginalnej funkcji 
(rozszerzonej o dodatkowe argumenty --- zmienne wolne) do zmiennych wolnych.
Na funkcji \texttt{add} została wykonana ta transformacja:
\begin{lstlisting}[frame=lines]
let make_adder x = 
    let add_extended_with_free_vars x y = x + y
    let add = add_extended_with_free_vars x

    add
\end{lstlisting}

Po tym etapie funkcję \texttt{add\_extended\_with\_free\_vars} można przenieść 
na globalny poziom (\textit{lambda lifting}). Funkcja \texttt{add} jest teraz zwykłym 
przypisaniem wyrażenia do symbolu, więc może być łatwo przetłumaczone na 
niskopoziomowy kod.

% 1. Co to są zagnieżdżone funkcje 

% 2. Na czym polega trudność w ich implementacji

% 3. Jak zostały zaimplementowane: lambda lifting + closure conversion + 
% wykorzystanie aplikacji częściowej

\section{Rekordy}

Rekordy są podstawowym sposobem na tworzenie własnych typów danych w wielu 
językach programowania. Do MonoMLa zostały wprowadzone głównie po to, 
aby urozmaicić przykłady zastosowania klas typów. 

Jako że LLVM IR wspiera struktury, które są odpowiednikiem implementowanych 
rekordów, dodanie ich do języka nie stanowiło problemu. W obecnej 
implementacji 
wszystkie struktury alokowane są na stercie i przekazywane przez wskaźnik.
Pola struktury są pamiętane przez ich wartość, chyba że polem jest inna 
struktura. Są trwałym typem danych, więc aktualizacja pól struktury 
z wyrażeniem \texttt{with} powoduje skopiowane zawartości całej struktury do 
nowej instancji.

\section{Let polimorfizm}

% 1. Krótki opis, czym jest let-polimorfizm
% // Bez imperatywanych
Bez let polimorfizmu (polimorfizm parametryczny) ciężko wyobrazić sobie 
nowoczesny język. 
Mimo wygody, jaką dostarcza programiście, często wiąże się z dodatkowym
obciążeniem czasowym i pamięciowym. Polimorficzna funkcja  \newline
\lstinline[language=Caml]!let identity x = x! może być użyta niezależenie
od typu podanego argumentu. Jednak jeśli funkcja \texttt{identity} 
jest aplikowana do argumentów typu \texttt{int} i \texttt{float}, to nie jest 
jasne, jak powinien wyglądać jej wygenerowany kod. Argument typu \texttt{float}
zostałby przekazany przez specjalny rejestr dla liczb zmiennoprzecinkowych, 
inny od tego dla argumentu typu \texttt{int}. W wygenerowanym kodzie jasno
należy określić, jaki wariant będzie wspierać dana funkcja. Dlatego wiele 
języków rozwiązuje ten problem poprzez jednorodną reprezentację wszystkich 
typów, które mogą być użyte w funkcjach polimorficznych. Jednorodna 
reprezentacja sprowadza się do alokowania wartości obiektu na stercie, a 
następnie przekazywanie wskaźnika na ten obiekt. Wszystkie wskaźniki 
niezależnie od typu i rozmiaru obiektu, na który wskazują, mają ten sam 
rozmiar i są przekazywane w ten sam sposób. Niesie to ze sobą kilka wad.
Przykładowo, dla każdego inta, który sam zajmuje $4$ bajty,
dodatkowo alokowane jest $8$ bajtów na wskaźnik do niego. Jako że jest 
zaalokowany na stercie, będzie musiał być ręcznie zwolniony przez programistę 
lub przez automatyczne odśmiecanie pamięci (które często występuje w językach 
funkcyjnych).

% // edna bibliografia -> Real World Ocaml x2 => x1
 
Do języków, które stosują powyższą metodę należą m. in. Java 
\cite{type_erasure} i Haskell 
\cite[Haskell implementation]{haskell_poly}.
W Haskellu konieczna jest taka reprezentacja danych także ze względu na jego 
leniwość. Dostępne w nim są także prymitywne typy reprezentowane przez 
ich wartość (ang. unboxed types), takie jak $\verb!Int#!$ i 
$\verb!Double#!$. Jednak nie mogą być one użyte w funkcjach polimorficznych. 
W fazie optymalizacji kompilator GHC może zamienić typ boxed 
na unboxed, ale nie jest to gwarantowane. Jako że kierowałem się wydajnością
przy implementacji kompilatora MonoMLa, to rozwiązanie nie jest 
satysfakcjonujące.

OCaml reprezentuje inty i wskaźniki na jednym słowie 
maszynowym \cite{levity_polymorphism}. 
To czy do funkcji został przekazany wskaźnik, czy int
przez wartość jest rozpoznawane na podstawie najniższego bitu, który jest 
traktowany jak znacznik \cite[Chapter 20]{real_ocaml}.
Jeśli wynosi $1$ to dana wartość jest intem.
To rozwiązanie pozwala na uniknięcie większości narzutu przy wykonywaniu 
operacji na typach prymitywnych, ale wiąże się z niestandardowym podejściem do 
arytmetyki liczb i wciąż nie pozwala na przekazywanie przez wartość typów danych 
większych niż słowo maszynowe. W związku ze wspominanymi wadami tego 
rozwiązania nie zdecydowałem się go zaimplementować.

Języki takie jak C++ i Rust \cite{levity_polymorphism} oraz kompilator SMLa 
MLton \cite{mono_mlton}, wyspecjalizowują każdą polimorficzną funkcję przed 
fazą generowania 
kodu. Ten proces nazywany jest \textit{monomorfizacją}. Dokładniej, polega on na 
utworzeniu osobnej 
implementacji polimorficznej funkcji dla każdego konkretnego typu, który 
został 
podstawiony pod typ ogólny. W C++ użytkownik może explicite podać,
dla jakich typów ukonkretnia daną funkcję, bądź może być to wykryte przez 
kompilator. 
Przykład polimorficznej funkcji w 
C++ z użyciem szablonów (ang. template):

\begin{lstlisting}[frame=lines]
template<class Type1, class Type2>
void foo(Type1 t1, Type2 t2) {
    // ...
}

int main() {
    foo<std::string, int>("hello world", 42);
    foo("hello world2", 24);
    foo(1.0, 4.0);
}
\end{lstlisting}

Dla funkcji \texttt{foo} z powyższego przykładu zostaną wygenerowane dwie 
implementacje, a oryginalne wywołania funkcji zostaną już w fazie kompilacje
zamienione na wywołania odpowiednich, wyspecjalizowanych wersji tej funkcji.
Takie rozwiązanie pozwala na przekazanie dowolnego typu przez jego wartość, 
bez zmiany jego reprezentacji. Jednak nie jest ono pozbawione wad. 
Zwiększa rozmiar wygenerowanego kodu, tym samym 
wydłużając czas kompilacji i powiększając rozmiar wynikowego programu. Kolejną 
wadą w praktycznych zastosowaniach, jest fakt, że wysokopoziomowy kod 
implementacji funkcji polimorficznej musi być opublikowany wraz z wygenerowaną 
bibliotekę, aby istniała możliwość wywołania tej funkcji dla typów, dla 
których nie była wcześniej ukonkretniona. Mimo to, język C++ cieszy 
się ogromną popularnością, a system szablonów jest szeroko używany, także w 
zastosowaniach produkcyjnych. Dodatkowo, statyczna monomorfizacja funkcji 
nie pozwala na zastosowanie polimorficznej rekursji, chociaż 
nie jest ona popularną cechą języków programowania.

W MonoMLu postanowiłem zaimplementować rozwiązanie bazujące na 
monomorfizacji. Jest ono zgodne z założeniami projektu oraz dobrze współgra z 
pozostałymi rozwiązaniami. W trakcie inferencji typów każda polimorficzna 
funkcja z MonoMLa jest reprezentowana w kompilatorze jako funkcja z 
ukonkretnień typów ogólnych w implementację. Gdy w fazie generacji kodu 
dochodzi do wywołania funkcji polimorficznej, muszą być znane wszystkie 
ukonkretnienia. Wtedy wywoływana jest funkcja generująca implementację na 
podstawie typów konkretnych. Implementacje funkcji dla tych samych typów 
konkretnych są zapamiętywane.

% znanej funkcji jest zapamiętywane dla jakich typów została ukonkretniona. 
% Następnie w fazie generowania kodu, dla każdego różnego zbioru ukonkretnień 
% typów ogólnych, tworzona jest odpowiednia implementacja funkcji. Programista 
% nie wybiera, która implementacja

% 2. Sposoby implementacji w różnych językach, zalety i wady 
% 3. Sposób implementacji u mnie

\section{Inferencja typów}

Inferencja typów zwalnia programistę z obowiązku wyspecyfikowania typów w
każdej deklaracji, pozostawiając wszystkie zalety statycznego systemu typów.
W MonoMLu działa ona następująco. Na początku każdemu argumentowi,
który nie został adnotowany przez użytkownika typem konkretnym, zostaje 
przypisany inny typ ogólny. Podczas inferencji w ciele funkcji, dla 
każdego wyrażenia, dla którego może być wywnioskowane jakieś ograniczenie 
(np. warunek w \textit{if} powinien mieć typ bool), odpowiednia 
równość między typami zostaje zapisana w drzewie ast tej funkcji. Po 
przetworzeniu funkcji zostaje zbudowany graf równości między typami. 
Sprawdzane jest, czy któreś argumenty w ciele funkcji zostały ukonkretnione, 
jeśli tak to definicja funkcji jest aktualizowana, jeśli nie to typ pozostaje
ogólny. Graf równości typów jest także używany w celu znalezienia konkretnych 
typów przy wywoływaniu polimorficznej funkcji (dzieję się to w fazie 
generowania kodu). 

\textbf{Uwaga.} Przy wywoływaniu polimorficznej funkcji, kompilator 
musi być w stanie ukonkretnić wszystkie typy ogólne. Typ argumentu może pozostać 
nieukonkretniony, jeśli argument nie będzie używany w ciele funkcji. W takim 
przypadku kompilator zwróci błąd, bo nie będzie w stanie wygenerować kodu dla 
funkcji z polimorficznym argumentem (już po przeprowadzeniu monomorfizacji).

% TODO: O optymalizacji z union finda.

\section{Klasy typów}
% 1. Czym są? Po co? 
Najpopularniejszą implementacją klas typów, jest ta zastosowana w Haskellu. 
Jej idea polega na przekazywaniu słownika (rekordu) z implementacjami funkcji 
z danej instancji klasy (ang. dictionary passing) 
\cite{implementing_type_classes, type_class_wadler88}. Przedstawię w jaki sposób 
działa ta implementacja, porównując kod używający klas typów w Haskellu i 
odpowiadający mu kod w OCamlu (w którym nie ma klas typów).

Deklaracja klasy typów w Haskellu:
% \noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[frame=lines]
class Show a where 
    show :: a -> String
\end{lstlisting}
% \end{minipage}\hfill
% \begin{minipage}{.45\textwidth}

Deklaracja odpowiednika klasy typów w OCamlu z
użyciem metody przekazywania słownika:
\begin{lstlisting}[frame=lines]
type 'a show = { 
    show : 'a -> string 
} 
\end{lstlisting}
% \end{minipage}

W przypadku Haskella zdefiniowaliśmy klasę typów 
\texttt{Show} z metodą 
\texttt{show} o typie $a \rightarrow String$. W przypadku OCamla musieliśmy 
stworzyć polimorficzny rekord z jednym 
polem \textit{show}. Instancja tego rekordu będzie instancją tej klasy 
dla danego typu. Następnie definiujemy instancje klasy w Haskellu:
\begin{lstlisting}[frame=lines]
instance Show String where
    show s = "'" ++ s ++ "'"

instance Show Bool where
    show True = "true"
    show False = "false" 
\end{lstlisting}
Instancje klasy \texttt{Show} w OCamlu zwracają 
rekord z odpowiednimi implementacjami zapisanymi w polach rekordu. 
% Listing $3..12$ zawiera standardową deklaracje instancji klasy w Haskellu.

% \noindent\begin{minipage}{.45\textwidth}
% \end{minipage}\hfill
% \begin{minipage}{.45\textwidth}
\begin{lstlisting}[frame=lines]
let show_string = {
    show = fun s -> "'" ^ s ^ "'"
}

let show_bool = {
    show = function 
           | false -> "false"
           | true  -> "true"
}
\end{lstlisting}
% \end{minipage}

Funkcja, która korzysta z typu będącego instancją klasy, musi przyjmować 
dodatkowy argument --- słownik z implementacją metod klasy. 
% Porównanie na listingach $3..14$ o $3..15$.

\begin{lstlisting}[frame=lines]
let printArg show_instance arg = 
    show_instance.show arg
    |> printf "arg: %s" 

let main1 = printArg show_bool true 

let main2 = printArg show_string "Hello"
\end{lstlisting}
Korzystanie z instancji klasy w Haskellu jest dużo bardziej przejrzyste.
% \noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[frame=lines]
printArg :: Show a => a -> IO ()
printArg arg = 
    putStrLn ("arg: " ++ show arg)

main1 = printArg True
main2 = printArg "Hello World"
\end{lstlisting}
% \end{minipage}\hfill

% \begin{minipage}{.45\textwidth}
% \end{minipage}

% TODO: O tym że to może być bardziej uciążliwe \newline
% jak są klasy bazowe: 
% http://okmij.org/ftp/Computation/typeclass.html

Zasadnicza różnica między symulowaniem klas typów w języku ich 
niewspierającym a użyciem ich w Haskellu jest to, że to do użytkownika należy 
udowodnienie istnienia instancji klasy dla danego typu.

Metoda przekazywania słownika nie niesie ze sobą dużego narzutu na czas 
kompilacji i wykonywania programu. Wymaga dodania co najmniej
jednego argumentu do funkcji polimorficznych korzystających z klas typów. 
Jednak w implementacji klas typów w MonoMLu, ze względu na decyzje 
podjęte w poprzednich cechach języka (monomorfizacja dla let polimorfizmu), 
nie skorzystałem z tej metody. Po przeprowadzeniu monomorfizacji, w kodzie nie 
występują żadne funkcje polimorficzne. Jedyne co należy zrobić w kolejnej 
fazie, to sprawdzić, czy dla danego typu i klasy istnieje instancja. Jeśli tak,
to użycie każdej metody z tej klasy dla konkretnego typu należy zamienić 
na wywołanie odpowiedniej implementacji. Po tym przekształceniu kod jest 
pozbawiony wszystkich konstrukcji klas typów, zawiera jedynie ich 
implementacje i wywołania odpowiednich metod. Oczywistą zaletą tego rozwiązania
jest fakt, że te wysoko poziomowe abstrakcje nie wiążą ze sobą żadnego kosztu.
Jest to istotna cecha w praktycznych zastosowania, bo pozwala na swobodne 
korzystanie z wysokopoziomowych konstrukcji języka, bez rozważania nad ich 
wpływem na wydajność. Jednak z tym rozwiązaniem związane są wszystkie wady 
monomorfizacji: konieczność kompilacji całego kodu 
programu na raz, 
brak rekursji polimorficznej oraz brak polimorfizmu wyższych 
rzędów (ang. higher-rank polymorphism).
Z podobnego rozwiązania przy implementacji klas typów 
korzysta MLton \cite{okmij}.

% 2. Sposoby implementowania, porównanie do pracy TODO

% 3. Jak zostały zaimplementowane, dlaczego tak

\chapter{Testy wydajnościowe}

W celu sprawdzenia, czy zastosowanie monomorfizacji faktycznie pozwala na 
zmniejszenie narzutu czasowego, związanego z częściową aplikacją, zdecydowałem 
się przeprowadzić testy wydajnościowe. Test ma na celu porównanie czasu wykonania 
programu wykorzystującego funkcję polimorficzną z czasem wykonania 
podobnego programu z monomorficzną wersją tej funkcji. Testowana funkcja musi 
być na tyle prosta, aby to proces wywoływania funkcji i przekazywania 
argumentów zajmował większość czasu wykonania programu. 

\section{Sposób testowania}
Testy zostaną przeprowadzone z użyciem narzędzia \textit{hyperfine}\cite{hyperfine}. 
Pozwala ono na uruchomienie wybranego programu wielokrotnie. 
Automatycznie oblicza średni czas działania programu i odchylenie standardowe.
Uruchamia także na początku wybrane programy, bez mierzenia czasu, aby zminimalizować 
wpływ pamięci podręcznej.

W tym przypadku testowana 
funkcja będzie rekurencyjnie obliczała $n * change + init$, gdzie $n$, $change$ i $init$ 
to parametry wywołania będące liczbami całkowitymi. Parametr $n$ będzie określał 
liczbę wywołań funkcji. Kod testowanej funkcji:
\begin{lstlisting}[frame=lines]
let rec sumPoly n (curr : 'a) (x : 'a) : 'a = 
    if n = 0 then curr 
    else sumPoly (n - 1) (add curr x) x 
\end{lstlisting}
Aby mieć pewność, że testowana funkcja jest rzeczywiście traktowana jako 
polimorficzna, nie użyłem wbudowanego operator $+$ obsługującego jedynie typ 
\texttt{int}. Dodałem klasę typów \texttt{Num} z polimorficzną funkcją 
\texttt{add} oraz instancję klasy dla typu \texttt{int}:
\begin{lstlisting}[frame=lines]
class Num 'a where 
    add : 'a -> 'a -> 'a 

instance Num int where 
    let add x y = x + y 
\end{lstlisting}
Łatwo można dodać kolejną instancję klasy \texttt{Num} dla innego typu i sprawdzić, 
że funkcja \texttt{sumPoly} działa dla nowego typu bez żadnych zmian w jej 
implementacji:
\begin{lstlisting}[frame=lines]
type pair = { first : int; second : int }

instance Num pair where 
    let add (x : pair) (y : pair) = 
        { x with first = x.first + y.first
                 second = x.second + y.second
        }

let _ = 
    let init = { first = 12; second = 1}
    let change = { first = 2; second = 3} 
    let res = sumPoly 10000 init change 
    printn_int (res.first) 
\end{lstlisting}

Dla porównania monomorficzna wersja funkcji \texttt{sumPoly}: 
\begin{lstlisting}[frame=lines]
let rec sumMono n (curr : int) (x : int) = 
    if n = 0 then curr 
    else sumMono (n - 1) (add curr x) x 
\end{lstlisting}

Jako że obie funkcje chcę wywołać $10^8$ razy, a w obecnej implementacji
MonoMLa nie jest wykonywana optymalizacja rekursji ogonowej (ang. tail call 
recursion), wystąpiłoby przepełnienie stosu. Dlatego testowane funkcje 
\texttt{sumMono} i \texttt{sumPoly} są jednorazowo uruchamiane dla parametru 
$n$ równego $10^4$. Jeśli takich uruchomień będzie $10^4$ to sumarycznie
testowana funkcja zostanie uruchomiona $10^8$ razy. Testowana funkcja została 
opakowana w funkcje \texttt{iter}:
\begin{lstlisting}[frame=lines]
let rec iter n count init change = 
    if n > 0
    then 
        sumPoly count init change
        iter (n - 1) count init change
    else sumPoly count init change
\end{lstlisting}
Teraz głębokość rekursji wywołań obu funkcji nie przekroczy $10^4$, nie powodując 
przepełnienia stosu. Pełna implementacja testowanych funkcji znajduje się w plikach:
\texttt{benchmarks/MonoML/sumMono.la} i \texttt{benchmarks/MonoML/sumPoly.la}.

\section{Porównanie z innymi językami}

W celu sprawdzenia korzyści wynikających z przekazywania prostych typów danych 
przez wartość zamiast przez wskaźnik postanowiłem porównać czas wykonania 
testowanej funkcji zaimplementowanej w innych językach. Dla trzech wybranych 
języków: Haskell, Standard ML i Java, porównałem czas działania testowanej funkcji 
w wersji polimorficznej, dla której argumenty są opakowane i w wersji wyspecjalizowanej 
dla typu int. Czas działania tej samej funkcji w innych językach daje także pewną 
orientację o tym, jak optymalną implementację otrzymałem.

\subsection{Haskell}

Haskell udostępnia typy prymitywne, które są reprezentowane przez wartość. Nie 
mogą być one użyte w funkcji polimorficznej oraz są gorliwe. Ukonkretniona 
wersja funkcji \texttt{sum} w Haskellu, dla odpakowanego typu \texttt{Int\#}, 
wygląda następująco:
\begin{lstlisting}[frame=lines]
sumMono :: Int# -> Int# -> Int# -> Int# 
sumMono 0# curr _ = curr 
sumMono n curr x = sumMono (n -# 1#) (curr +# x) x
\end{lstlisting}
Konieczne jest używanie specjalnych operatorów arytmetycznych \texttt{-\#}
i \texttt{+\#}. 

W wersji polimorficznej musiałem jedynie upewnić się, że wywołania rekurencyjne 
będą wykonywane gorliwie, aby możliwie dokładnie zmierzyć koszt opakowywania 
argumentów. Zastosowałem operator gorliwej aplikacji \texttt{\$!}:

\begin{lstlisting}[frame=lines]
sumPoly :: Num a => Int -> a ->  a -> a
sumPoly 0 curr _ = curr 
sumPoly n curr x = sumPoly (n - 1) (curr + x) $! x
\end{lstlisting}

Implementacja w Haskellu znajduje się w plikach \newline
\texttt{benchmarks/Haskell/sumMono.hs} i \texttt{benchmarks/Haskell/sumPoly.hs}.

\subsection{Standard ML}

Do kompilacji programu w Standard MLu użyłem dwóch kompilatorów, MLton i SML/NJ.
MLton wykonuje monomorfizację funkcji polimorficznych, a SML/NJ opakowuje we 
wskaźnik nawet wyspecjalizowaną wersję funkcji dla typu int. Program skompilowany 
przez MLton posłuży jako porównanie wersji monomorficznej.

Kod w SMLu wygląda następująco:
\begin{lstlisting}[frame=lines]
fun sum add n curr x =
  if n = 0 
  then curr 
  else sum add (n - 1) (add (curr, x)) x

val _ = 
  print (Int.toString (
    sum (fn (x:int, y:int) => x + y) 100000000 12 2));
\end{lstlisting}
Pełna implementacja dla obu kompilatorów znajduje się w plikach \newline
\texttt{benchmarks/SmlNJ/sumPoly.sml} i \texttt{benchmarks/MLton/sumMono.sml}.

\subsection{Java}

Polimorfizm parametryczny jest także obecny w Javie (funkcje generyczne). 
Argumenty funkcji polimorficznych są automatycznie opakowywane we wskaźnik. 
Jednocześnie istnieje możliwość zaimplementowania wyspecjalizowanych wersji 
funkcji, które mogą przyjmować prymitywne typy danych przez wartość. Porównałem
czas działania funkcji generycznej i wyspecjalizowanej dla argumentów o tym samym 
typie. 

Kod programu w Javie: 
\begin{lstlisting}[frame=lines]
private static int sumMono(int n, int curr, int change) {
    while (n-- > 0) {
        curr += change;
    }

    return curr;
}

private static <T> T sumPoly(BiFunction<T, T, T> add, 
                                int n, 
                                T curr, 
                                T change) {
    while (n-- > 0) {
        curr = add.apply(curr, change);
    }

    return curr;
}
\end{lstlisting}
Całość znajduje się w pliku \texttt{benchmarks/Java/Sum.java}.

% \section{Oczekiwany wynik eksperymentu}

% Spodziew

\section{Otrzymane wyniki}

Każdy program wywoływał testowaną funkcje $10^8$ razy.
Po wielokrotnym uruchomieniu każdego programu otrzymałem średnią z czasów ich 
wykonań oraz odchylenie standardowe. Wyniki są przedstawione w Tablicy $4.1$.
Podane czasy działania są w milisekundach.
W ostatniej kolumnie podaję współczynnik czasu działania danej implementacji 
względem polimorficznej wersji w MonoMLu.
% \pagebreak

\begin{center}
\begin{table}
\caption{Wyniki testów wydajnościowych}
\begin{tabular}{|| l | l | r | r | r ||} 

 \hline
 Język & Implementacja & Średni czas & $\sigma$ & Współczynnik \\ 
 \hline\hline
 Haskell (GHC)        & Wyspecjalizowana & 39.1  & 8.2  & 0.10 \\ 
 Haskell (GHC)        & Polimorficzna    & 696.8 & 63.2 & 1.86 \\ 
%  \hline
 Java                 & Wyspecjalizowana & 140.1 & 65.7 & 0.37 \\ 
 Java                 & Polimorficzna    & 564.9 & 24.8 & 1.50 \\ 
%  \hline
 SML (MLton)  & Wyspecjalizowana & 151.0 & 13.7 & 0.40 \\ 
 SML (SML/NJ) & Polimorficzna    & 357.6 & 14.4 & 0.95 \\ 
%  \hline
 Mono ML              & Wyspecjalizowana & 327.0 & 52.3 & 0.88 \\ 
 Mono ML              & Polimorficzna    & 375.4 & 46.9 & 1.00 \\ 
 \hline
\end{tabular}
\end{table}
\end{center}

\chapter{Podsumowanie}

\section{Wnioski}

Z wyników widocznych na Tablicy $4.1$ jasno wynika, że w przypadku gdy 
argumenty funkcji były opakowywane we wskaźnik, istotnie wydłużał się czas 
działania programu. Największa różnica wystąpiła dla Haskella --- najszybsza była 
wyspecjalizowana wersja testowanej funkcji w Haskellu. Najpewniej wynika to 
ze złożonych optymalizacji, które wykonuje kompilator GHC, wiedząc, że
funkcja jest wywoływana gorliwie dla typu int. Jedynie w MonoMLu różnica między 
czasem działania funkcji polimorficznej i wyspecjalizowanej była znikoma.
Choć implementacja funkcji polimorficznych w MonoMLu nie okazała się najszybsza, 
to nie odstaje od popularnych kompilatorów. Dodatkowo dzięki zastosowaniu 
monomorfizacji, narzut czasowy związany z funkcjami polimorficznymi jest 
minimalny. Oznacza to, że dowolne optymalizacje zastosowane do wyspecjalizowanych
funkcji, będą mogły być automatycznie użyte przez funkcje polimorficzne.

Najtrudniejszym elementem przy tworzeniu kompilatora dla języka funkcyjnego 
okazała się efektywna implementacja częściowej aplikacji. Główną trudnością
było spełnienie założeń o optymalnym przekazywaniu zmiennych i unikaniu 
jednorodnej reprezentacji różnych typów danych poprzez boxowanie. Pomimo że 
jest to standardowa cecha wielu języków i istnieją opisy jej implementacji
w części z nich, to cele, które postawiłem, zaowocowały odmiennym rozwiązaniem.

Drugim celem projektu było wprowadzenie klas typów do języka z rodziny ML. 
Zastosowanie monomorfizacji znacznie ułatwiło ich implementację. To proste
rozszerzenie języka znacznie zwiększyło jego możliwości. Pozwoliło na 
pisanie modularnych funkcji oraz abstrakcję funkcjonalności od reprezentacji 
danych. Ponadto nie wprowadziły one żadnego narzutu pamięciowego i czasowego.

% \pagebreak

\section{Dalsze prace}

Tworzenie kompilatorów jest obszernym i czasochłonnym zadaniem. Zdecydowałem 
się pominąć pewne standardowe cechy języków funkcyjnych, aby lepiej skupić 
się na celach projektu. W przypadku kontynuacji pracy nad językiem \textit{MonoML}
i kompilatorem, naturalnym rozwinięciem byłby następujące elementy:

\begin{itemize}
  \item Polimorficzne struktury danych, w tym polimorficzna tablica. Obecnie 
  wspierane są jedynie rekordy z polami, które muszą mieć konkretny typ. 
  Przy zastosowaniu monomorfizacji, ich implementacja jest łatwa. Komplikuje
  się jedynie inferencja typów. Może się okazać koniecznym obsłużenie słabych 
  polimorficznych typów \cite{weak_poly_ocaml}.
  \item Wyrażenia lambda. Mogłyby być zrealizowane poprzez zamianę ich na 
  globalne wyrażenia let o unikalnych nazwach. 
  \item Warianty \cite[Chapter 6]{real_ocaml}. Są bardzo popularną i użyteczną cechą 
  języków z rodziny ML. Dzięki nim można łatwo zaimplementować typy danych takie 
  jak \textit{Optional} lub trwała lista.   
  \item Klasy typów z wieloma parametrami. Nie są obecne w standardzie 
  Haskell 98, jednak istnieje możliwość ich włączenia poprzez odpowiednią 
  dyrektywę. Ich implementacja byłaby łatwym 
  rozszerzeniem obecnej (z jednym parametrem), jednak dołożenie ich do języka 
  wiązałoby się z pewnymi niejednoznacznościami \cite{multi_params_tcs}
  przy wyborze odpowiedniej instancji klasy. Koniecznym mogłoby by się okazać 
  dodanie zależności funkcyjnych (ang. functional dependencies) \cite{fun_deps}.
  \item Kompilacja wielu plików. Obecna implementacja pozwala na skompilowanie 
  jednego pliku. Umożliwienie kompilacji wielu plików w jednym projekcie nie 
  jest trudnością, gdyż wystarczy połączyć pliki w odpowiedniej kolejności
  (lub też pozwolić użytkownikowi na zdefiniowanie ich kolejności). Tworzenie 
  przenośnych bibliotek może okazać się wyzwaniem ze względu na zastosowanie 
  monomorfizacji.
  \item Składnia pozwalająca na opcjonalne użycie słów kluczowych, które tworzą 
  kontekst (w OCamlu to \texttt{begin}, \texttt{end}, \texttt{in} oraz nawiasy).
  Jest to cecha znana z języka F\#. Należałoby przenieść wykrywanie 
  całych bloków wciętego kodu do etapu analizy leksykalnej. Wcięcia generowałyby 
  różne tokeny (nie tylko \textit{INDENT} i \textit{DEDENT}), w zależności 
  od kontekstu, w którym się znajdują. Dokładny opis tego rozwiązania znajduje 
  się w specyfikacji języka F\# $4.0$\cite{fs_spec}.
  \item Reprezentowanie małych rekordów poprzez ich wartość. Rekord zawierający 
  dwa pola będącymi intami, może być zapamiętany w jednym słowie maszynowym. 
  Obecnie wszystkie rekordy są pamiętane przez wskaźnik do ich zawartości, 
  jednak dzięki monomorfizacji zastosowanie tej optymalizacji nie stanowi 
  problemu.

\end{itemize}

% - klasy typów z wieloma parametrami
% - kompilacja różnych plików
% - reprezentacja struktur przez wartość 
% - ewentualna rekurencja polimorficzna
% - zagnieżdżone wzajemnie rekurencyjne let
% - lepsze parsowanie

\chapter{Instrukcja obsługi}

\section{Instalacja}

Projekt można skompilować w systemie Linux.
Uprzednio należy wykonać następujące kroki. 

\begin{enumerate}
  \item Instalacja kompilatora OCamla. Instrukcja dostępna na stronie: \newline
  \texttt{https://ocaml.org/docs/install.html}.
  \item Instalacja menadżera pakietów \textit{OPAM}. 
  Instrukcja dostępna na stronie: \newline
  \texttt{https://opam.ocaml.org/doc/Install.html\#Binary-distribution}
  \item Instalacja LLVMa. Instrukcja dostępna na stronie: \newline
  \texttt{https://llvm.org/}.
  \item Wymagany jest kompilator LLVM w wersji $6$. Zainstalowaną 
  wersję można sprawdzić poleceniem:
  \begin{lstlisting}[language=bash]
  $ llc --version
  \end{lstlisting}
  \item Ustawienie wersji kompilatora:
  \begin{lstlisting}[language=bash]
  $ opam switch 4.05.0
  \end{lstlisting}
  \item Konfiguracja menadżera pakietów:
  \begin{lstlisting}[language=bash]
  $ eval `opam config env`
  \end{lstlisting}
  \item Instalacja bibliotek. Należy uruchomić skrypt \texttt{install\_deps.sh}
   instalujący odpowiednie pakiety z użyciem OPAMa. Plik znajduje się 
   w głównym folderze 
  \texttt{monoml-compiler}. 
  \begin{lstlisting}[language=bash]
  $ ./install_deps.sh
  \end{lstlisting}
  \item Kompilacja projektu:
  \begin{lstlisting}[language=bash]
  $ make 
  \end{lstlisting}
\end{enumerate}

% \begin{lstlisting}[caption=Instancja klasy w OCamlu, frame=tlrb]{Name}
% - install [*ocaml*](https://ocaml.org/docs/install.html) and [*opam*](https://opam.ocaml.org/doc/Install.html)

% - switch to *ocaml* version `4.05.0`:

% ```bash
% $ opam switch 4.05.0
% ```

% - configure *opam* in the current shell:

% ```bash
% $ eval `opam config env`
% ```

% - install *jbuilder* and *sedlex*:

% ```bash
% $ opam install jbuilder sedlex
% ```

% - install rest of dependencies by following output from these commands (except for `menhirLib`):

% ```bash
% $ jbuilder external-lib-deps --missing @runlangc
% $ jbuilder external-lib-deps --missing @runtest
% ```

%   You will be asked to install required modules through *opam*, and some external libraries through *depext*.
% - install [LLVM 5](https://llvm.org/) and *gcc* (*gcc* is usually present on linux)

%  Finally check whether you installed everything correctly:
% ```bash
% $ llc --version    # Expect something like LLVM version 5.0.1, later versions should also be fine.
%                    # NOTE: Version 3.8 will *not* work.
% $ gcc --version
% $ jbuilder --version
% \end{lstlisting}

\section{Sposób użycia}
Skompilowany plik wykonywalny kompilatora znajduje się w folderze \newline
\texttt{monoml-compiler/\_build/default/langc/langc.exe}. Pierwszym argumentem 
musi być ścieżka do kodu źródłowego w Langu. Program posiada także dodatkowe 
argumenty. 

\begin{itemize}
  \item \texttt{--help} --- Opis użycia oraz dostępnych argumentów. 
  \item \texttt{-o} --- Opcjonalny argument dzięki któremu można określić 
  ścieżkę i nazwę skompilowanego programu. Domyślnie jest to \texttt{a.out}.
  \item \texttt{--ll-only} --- Dodanie tego argumentu powoduje wygenerowanie 
  kodu w języku pośrednim LLVM IR do pliku \texttt{out.ll}, bez tworzenia pliku 
  wykonywalnego. 
\end{itemize}

Przykładowy program z folderu \texttt{test/input} można skompilować następującym 
poleceniem: 
\begin{lstlisting}[language=bash]
$ _build/default/langc/langc.exe test/input/hello_world.la # kompilacja 
$ ./a.out # uruchomienie wygenerowanego programu 
\end{lstlisting}

\textbf{Uwaga.} Podczas kompilacji program szuka pliku \texttt{external.c} w 
obecnym folderze (tym, w którym znajduje się użytkownik). Zawiera on  
implementacje kilku funkcji bibliotecznych w C. Znajduje on się w 
głównym folderze projektu \newline(\texttt{monoml-compiler}), dlatego 
zalecanym jest kompilowanie z tego folderu.

\subsection{Uruchomienie testów wydajnościowych}
Kody programów użytych do testów wydajnościowych znajdują się w folderze 
\texttt{benchmarks/}. W celu uruchomienia testów wydajnościowych należy najpierw 
zainstalować następujące narzędzia i kompilatory:

\begin{itemize}
  \item \texttt{hyperfine: https://github.com/sharkdp/hyperfine}
  \item \texttt{GHC: https://www.haskell.org/ghc/}
  \item \texttt{SML/NJ: http://smlnj.org/}
  \item \texttt{MLton: http://mlton.org/}
  \item \texttt{Java: http://openjdk.java.net/} 
\end{itemize}

Testy wydajnościowe uruchamia się następującym poleceniem (w głównym folderze 
projektu):
\begin{lstlisting}[language=bash]
$ make benchmark
\end{lstlisting}

\subsection{Przykładowe programy i testowanie}

W folderze \texttt{test/input} znajduje się dwadzieścia przykładowych programów
napisanych w MonoMLu (pliki z rozszerzeniem \texttt{.la}). Testują różne funkcjonalności języka m. in 
częściową aplikację, polimorfizm, klasy typów oraz inferencję. 
Wszystkie testy można uruchomić następującym poleceniem:
\begin{lstlisting}[language=bash]
$ make test
\end{lstlisting}
Testy należy uruchomić z głównego folderu projektu.
Testowanie polega na skompilowaniu każdego programu z rozszerzeniem \texttt{.la}
z folderu \texttt{test/input}, uruchomieniu go i porównaniu standardowego 
wyjścia z odpowiadającym plikiem o sufiksie \texttt{-expected-out.txt}.

\section{Użyte narzędzia i biblioteki}

\begin{itemize}
  \item \texttt{OCaml: https://ocaml.org/}
  \item \texttt{Menhir: http://gallium.inria.fr/\~fpottier/menhir/}
  \item \texttt{Sedlex: https://github.com/alainfrisch/sedlex}
  \item \texttt{High OLLVM}: Biblioteka opakowująca oficjalną bibliotekę do 
  generowania kodu LLVM IR w funkcyjny interfejs. Bazująca w przeważającej większości 
  na bibliotece \texttt{ollvm}: 
  \texttt{https://github.com/OCamlPro/ollvm}.
  Ta zależność została dołączona wraz z kodem źródłowym kompilatora.
  \item \texttt{OCaml-parsing: https://github.com/smolkaj/ocaml-parsing}
  \item \texttt{Core: https://github.com/janestreet/core} 
  \item \texttt{Dune (JBuilder): https://github.com/ocaml/dune} 
  \item \texttt{OUnit: http://ounit.forge.ocamlcore.org/} 
\end{itemize}

% - OCaml 
% - Menhir 
% - Sedlex 
% - Template użycia sedlexa
% - High Ollvm 

% - [ocaml-parsing](https://github.com/smolkaj/ocaml-parsing) - boilerplate code for parsing in OCaml
% - [Menhir](http://gallium.inria.fr/~fpottier/menhir/) - LR(1) parser generator
% - [Sedlex](https://github.com/alainfrisch/sedlex) - lexer generator
% - Jane Street's [core](https://ocaml.janestreet.com/ocaml-core/latest/doc/), the inofficial standard library for OCaml
% - Jane Street's [jbuilder](https://github.com/janestreet/jbuilder), an OCaml build system
% - Other libraries specified in jbuild files

\section{Struktura projektu}

Projekt znajduje się w folderze \texttt{monoml-compiler}.

\begin{itemize}
  \item \texttt{compiler/} --- Biblioteka kompilatora. Zawiera wszystkie 
  najważniejsze elementy procesu kompilacji. Głównym jej zadaniem jest 
  wygenerowanie kodu LLVM IR dla podanego kodu MonoMLa.
  \item \texttt{compiler/parsing/grammar.mly} --- Gramatyka w składni Menhira.
  \item \texttt{compiler/parsing/lexer.cppo.sedlex.ml} --- Analiza leksykalna.
  \item \texttt{compiler/parsing/ast.ml} --- Typy reprezentujące drzewo składni 
  po parsowaniu.
  \item \texttt{compiler/codegen.ml} --- Zbiór funkcji odpowiedzialnych za 
  generowanie kodu.
  \item \texttt{compiler/lang\_types\_def} --- Definicje typów reprezentujących 
  typy z MonoMLa.
  \item \texttt{compiler/lang\_types} --- Funkcje służące znalezieniu
  typu wyrażeń. Inferencja typów.
  \item \texttt{compiler/letexp.ml} --- Generowaniu kodu funkcji 
  (wyrażeń \textit{let}). 
  Główna część implementacji częściowej aplikacji.
  \item \texttt{compiler/envn.ml} --- Środowisko używane przy 
  generacji kodu.
  \item \texttt{compiler/typed\_ast\_def} --- Typy reprezentujące drzewo 
  z otypowanymi wyrażeniami.
  \item \texttt{compiler/typed\_ast} --- Zamiana drzewa otrzymanego po 
  sparsowaniu na drzewo z otypowanymi wyrażeniami. Wykonywane są także 
  transformacje: modułów, funkcji zagnieżdżonych, closure conversion
  oraz klasy typów.
  \item \texttt{langc/} --- Projekt odpowiedzialny za plik wykonywalny 
  kompilatora. Kompilacja kodu LLVM IR, obsługa parametrów wywołania programu
  oraz odczytywanie kodu z pliku wejściowego.
  \item \texttt{langc/compilation/compilation.ml} --- Kompilacja wygenerowanego 
  kodu LLVM z użyciem programu \texttt{llc} (kompilator LLVM IR) i 
  \texttt{gcc}.
  \item \texttt{test/} --- Projekt zawierający testy kompilatora.
  \item \texttt{test/input/} --- Kody źródłowe w MonoMLu do przetestowania. W czasie 
  testowania każdy z nich zostanie skompilowany, uruchomiony, a standardowe
  wyjście porównane z plikami \texttt{-expected-out.txt} z tego samego folderu.
  \item \texttt{test/compiler\_tests.ml} --- Moduł generujący testy na podstawie 
  plików znajdujących się w folderze \texttt{test/input/}.
  \item \texttt{high-ollvm/} --- Biblioteka udostępniająca funkcyjne api do 
  generowaniu kodu LLVM IR, bazowana na bibliotece ollvm\cite{ollvm}.

\end{itemize}

%%%%% BIBLIOGRAFIA
\bibliographystyle{plain}
\bibliography{bibliography.bib}

% \begin{thebibliography}{1}
 
% \bibitem{sml_proposal} 
% The Standard ML Core Language, by Robin Milner, July 1984.
% \\\texttt{http://sml-family.org/history/SML-proposal-7-84.pdf}

% \bibitem{modules_vs_typeclasses} 
% ML Modules and Haskell Type Classes:
% A Constructive Comparison
% Stefan Wehr and Manuel M. T. Chakravarty
% \\\texttt{https://www.cse.unsw.edu.au/\~chak/papers/modules-classes.pdf}

% \bibitem{no_hkt_in_rust} 
% Higher kinded polymorphism - Rust Github issues.
% \\\texttt{https://github.com/rust-MonoML/rfcs/issues/324}

% \bibitem{traits_as_obj_rust} 
% Using Trait Objects that Allow for Values of Different Types. Rust.
% \\\texttt{https://doc.rust-MonoML.org/book/second-edition/ch17-02-trait-objects.html}

% \bibitem{llvm} 
% LLVM.
% \\\texttt{https://llvm.org/}

% \bibitem{llvm_in_ocaml} 
% “Implementing a language with LLVM” tutorial.
% \\\texttt{https://llvm.org/docs/tutorial/OCamlLangImpl1.html}

% \bibitem{cpp_bind} 
% std::bind - C++ Reference
% \\\texttt{https://en.cppreference.com/w/cpp/utility/functional/bind}

% \bibitem{fslang_typeclass} 
% F\# Language - User Voice.  Suggestions about Future evolution of the F\# Language and Core Library.
% \\\texttt{https://fslang.uservoice.com/forums/245727-f-language/filters/top}

% \bibitem{python_indentation} 
% Indentation. Python Reference Manual.
% \\\texttt{https://docs.python.org/2.5/ref/indentation.html}

% \bibitem{levity_polymorphism} 
% Levity Polymorphism.
% \\\texttt{https://www.microsoft.com/en-us/research/wp-content/\newline
% uploads/2016/11/levity-pldi17.pdf}

% \bibitem{fast_curry} 
% Making a Fast Curry: Push/Enter vs.
% Eval/Apply for Higher-order Languages. Simon Marlow, Simon Peyton Jones
% \\\texttt{https://www.microsoft.com/en-us/research/wp-content/uploads/\newline
% 2016/07/eval-apply.pdf}

% \bibitem{fun_deps} 
% Functional dependencies.
% \\\texttt{https://wiki.haskell.org/Functional\_dependencies}

% \bibitem{multi_params_tcs} 
% Multi-parameter type class
% \\\texttt{https://wiki.haskell.org/Multi-parameter\_type\_class}

% \bibitem{fs_spec} 
% Specyfikacja języka F\# 4.0
% \\\texttt{https://fsharp.org/specs/language-spec/4.0/FSharpSpec-4.0-final.pdf}

% \bibitem{scala_traits} 
% Scala docs: Traits.
% \\\texttt{https://docs.scala-MonoML.org/tour/traits.html}

% \bibitem{rust_traits}
% Rust by example. Traits.
% \\\texttt{https://doc.rust-MonoML.org/rust-by-example/trait.html}

% \bibitem{tc_wiki}
% Type class. Wikipedia.
% \\\texttt{https://en.wikipedia.org/wiki/Type\_class?oldformat=true}

% \bibitem{type_erasure}
% Type Erasure. The Java Tutorials.
% \\\texttt{https://docs.oracle.com/javase/tutorial/java/generics/erasure.html}

% \bibitem{haskell_poly}
% Type Systems, Type Inference, and Polymorphism.
% \\\texttt{http://www.cs.tau.ac.il/\~msagiv/courses/pl14/chap6-1.pdf}

% \bibitem{menhir}
% Menhir.
% \\\texttt{http://gallium.inria.fr/\~fpottier/menhir/}

% \bibitem{ocaml_31bit}
% Chapter 20. Memory Representation of Values. Real World OCaml.
% \\\texttt{https://v1.realworldocaml.org/v1/en/html/memory-representation-of-values.html}

% \bibitem{mono_mlton}
% Monomorphise. MLton.
% \\\texttt
% {http://mlton.org/Monomorphise}

% \bibitem{templates_cpp}
% Template (C++). Wikipedia.
% \\\texttt
% {https://en.wikipedia.org/wiki/Template\_(C\%2B\%2B)?oldformat=true}

% \bibitem{type_class_wadler88}
% How to make \textit{ad--hoc} polymorphism less \textit{ad--hoc}. 
% P. Wadler, S. Blott
% \\\texttt
% {https://people.csail.mit.edu/dnj/teaching/6898/papers/wadler88.pdf}

% \bibitem{implementing_type_classes}
% Implementing Type Classes. John Peterson, Mark Jones
% \\\texttt
% {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.3952\&rep=rep1\&type=pdf}

% \bibitem{okmij}
% Implementing, and Understanding Type Classes.
% \\\texttt
% {http://okmij.org/ftp/Computation/typeclass.html}

% \end{thebibliography}

\end{document}
