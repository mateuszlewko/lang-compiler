% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[declaration,shortabstract]{iithesis}

\usepackage[utf8]{inputenc}

\usepackage{listings}
% \usepackage{color}

% \definecolor{dkgreen}{rgb}{0,0.6,0}
% \definecolor{gray}{rgb}{0.5,0.5,0.5}
% \definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
%   numberstyle=\tiny\color{gray},
%   keywordstyle=\color{blue},
%   commentstyle=\color{dkgreen},
%   stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=true,
  tabsize=3
}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Implementacja języka funkcyjnego z rodziny ML z użyciem 
                 systemu kompilacji LLVM}
\englishtitle   {English title}
\polishabstract { TODO polish abstract}
\englishabstract{ TODO english abstract}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Mateusz Lewko}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr hab. Dariusz Biernacki}
\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
% \transcriptnum {283197}                     % Numer indeksu
%\advisorgen    {dr. Jana Kowalskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Wprowadzenie}

Pierwsze prace nad językiem ML zaczął Robin Milner na początku lat 70. W~1984, 
dzięki jego inicjatywie, powstał Standard ML - ustandaryzowana wersja języka ML.
Już wtedy zawierał m. in. rozwijanie funkcji, dopasowanie do wzorca, inferencje
typów oraz moduły parametryczne \cite{smlproposal}. Są to elementy, które cechują
większość dzisiejszych funkcyjnych języków programowania. Od tego czasu powstało 
wiele języków z rodziny ML. Jednymi z najpopularniejszych są: OCaml, F\# oraz 
dialekty SMLa. 

\section{Klasy typów}
Większość języków z rodziny ML w celu lepszego ustrukturyzowania
programu stosuje system modułów. Pozwala on na podzielenie programu na 
niezależne~od~siebie funkcjonalności.
Klasy typów, których głównym cele jest wprowadzenie 
ad-hoc polimorfizmu do języka, mogą po części także spełnić to zadanie 
\cite{modules_vs_typeclasses}. 
Są obecne w językach takich jak Haskell, Scala czy Rust. Fakt, że pojawiają się
w nowych językach ogólnego zastosowania, świadczy o ich atrakcyjności z punktu 
widzenia programisty. Mimo to nieznane są żadne popularne języki ML korzystającego
z tego rozwiązania. Jedynym z celów tej pracy jest wprowadzenie klas typów do 
prostego języka funkcyjnego, bazującego na podstawowych cechach rodziny ML. W tym 
celu stworzyłem kompilator języka $Lang$, wymyślonego na potrzeby tej pracy.

\section{Efektywna implementacja języka funkcyjnego}
Drugim celem tej pracy jest implementacja głównych cech języków funkcyjnych w
możliwie optymalny sposób. Skupię się na optymalizacji czasu wykonania programu,
 kosztem długości wygenerowanego kodu. Kompilacja będzie się odbywać do kodu 
maszynowego, gdyż daje to lepszą wydajność otrzymanego programu. Stanowi to też 
większe wyzwanie przy kompilacji języka funkcyjnego, niż napisanie interpretera, 
ze względu na jego wysoką poziomowość. Oczywiście, trudnym będzie uzyskanie 
podobnej lub lepszej wydajności niż popularne kompilatory języków funkcyjnych,
gdyż te stosują dużą liczbę skomplikowanych optymalizacji. Skupię się nad tym, 
aby moja implementacja prostego języka funkcyjnego, była porównywalna wydajnością 
z popularnymi rozwiązaniami. Omówię i porównam sposoby w jaki zdecydowałem się 
zaimplementować podstawowe cechy języków funkcyjnych, a w szczególności: częściową 
aplikację, zagnieżdżone funkcje, polimorfizm i klasy typów. Moje rozwiązania będą 
bazować na pomysłach z różnych języków programowania, w tym imperatywnych. Wspomniane 
cechy omówię dokładniej, ponieważ odbiegają od rozwiązań stosowanych w popularnych językach
funkcyjnych.

\section{Infrastruktura LLVM}
% TODO: 
% 1. Co to jest? 

% 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

% 3. Jak działa kompilowanie do LLVM? 

% 4. Krótki opis high-ollvm 

W celu uproszczeniu konstrukcji nowego kompilatora i ułatwienia pracy z generowaniem 
niskopoziomowego kodu, zdecydowałem się skorzystać z infrastruktury LLVM. Jest to zbiór 
narzędzi i bibliotek wykorzystywanych przez wiele współczesnych kompilatorów. LLVM dostarcza 
kompilator LLVM IR, który jest niskopoziomowym językiem stworzonym na potrzeby pisania 
kompilatorów. Przykładowy program napisany w LLVM IR:

% \lstset{language=llvm}
\begin{lstlisting}[frame=single]
@.str = internal constant [14 x i8] c"hello, world\0A\00"

declare i32 @printf(i8*, ...)

define i32 @main(i32 %argc, i8** %argv) nounwind {
entry:
    %tmp1 = getelementptr [14 x i8], [14 x i8]* @.str, i32 0, i32 0
    %tmp2 = call i32 (i8*, ...) @printf( i8* %tmp1 ) nounwind
    ret i32 0
}
\end{lstlisting}

LLVM IR składa się przede wszystkim z: deklaracji i definicji funkcji, zmiennych globalnych, 
podstawowych bloków, przypisań oraz wywołań funkcji. Podstawowe bloki kodu jak i funkcje nie 
mogą być zagnieżdżone. 

W moim kompilatorze nie generuję kodu LLVM'a, korzystam z oficjalnej biblioteki dla OCamla, 
udostępniającej interfejs potrzebny do tworzenia elementów wygenerowanego kodu. System LLVM 
jest odpowiedzialny za ostatni etap procesu kompilacji, zamianę kodu pośredniego (LLVM IR) na 
assembler. Cały kod jest w postaci Single Static Assignment, do jednej zmiennej (etykiety) 
można przypisać tylko jedno wyrażenie. Dzięki takiej formie kodu pośredniego, LLVM jest w 
stanie przeprowadzić na nim pewne optymalizacje, przed wygenerowaniem kodu maszynowego. 

TODO: 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

\section{Klasy typów}

Jako pierwsze pojawiły się w języku Haskell. Początkowo zostały użyte w celu 
umożliwienia przeładowania operatorów arytmetycznych i równości. Od tego czasu, 
znaleziono dla nich więcej zastosowań w różnych językach programowania. W języku
Haskell, poza tym, że umożliwiają użycie przeładowanych funkcji, definiowania 
funkcjonalności wspólnej dla wielu typów (interfejsów), okazały się niezbędne 
do implementacji Monad. W języku systemowym Rust, odpowiednikiem klas typów są
$cechy$ (ang. trait). W podstawowych użyciach nie różnią się od klas typów, ale 
nie pozwalają na implementacje polimorfizmu wyższych rzędów (ang. 
Higher-kinder polymorphism). Inną istotną różnicą jest fakt, że klasa typów z 
Haskella nie definiuje nowego typu, jedynie pozwala na ograniczenie typu do 
instancji klasy. $Cecha$ z Rusta może być użyta jak zwykły typ, przykładowo 
można stworzyć listę zawierające obiekty, które są różnymi instancjami 
(implementacjami) $cechy$. W Haskellu istnieją także rozszerzenia, które 
pozwalają na definicje klas z wieloma parametrami. 

% Jakich językach i czym się różnią

Istnieje wiele wariantów klas typów oraz rozwiązań do nich podobnych, dlatego w swoim kompilatorze zdecydowałem się zaimplementować ich najprostszą wersje, 
umożliwiającą $ad-hoc$ polimorfizm.

Podstawowe użycie klas typów zaprezentuję na przykładzie Haskella. 
W celu stworzenia klasy typów $C$ dla typu ogólnego $a$, należy 
zdefiniować zbiór funkcji, które musi zawierać instancja tej klasy. Dla danego 
typu i klasy może istnieć co najwyżej jedna instancja. 

% \lstset{language=llvm}
\begin{lstlisting}[frame=single, caption=Przykładowa definicja klasy typów.]
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
\end{lstlisting}

W powyższym przykładzie definiujemy klasę $Eq$ zawierającą dwa operatory:~$==$ 
~oraz~$/=$. Powiemy, że typ ukonkretniony z $a$ jest instancją klasy $Eq$, jeśli zawiera deklaracje obu funkcji z odpowiednimi typami. Przykładowa instancja dla typu $Bool$, mogłaby wyglądać następująco:

\begin{lstlisting}[frame=single, caption=Instancja klasy $Eq$ dla typu $Bool$.]
instance Eq Bool where
  True == True = True 
  False == False = True 
  _ == _ = False
  l /= r = not (l == r)
\end{lstlisting}

\section{Let-polimorfizm}

Istnieją funkcje, których implementacja jest taka sama, niezależenie od typu dla
którego ją aplikujemy. Przykładowo, funkcja obliczają długość generycznej listy 
nie zależy od typu elementów, które się w niej znajdują. Funkcja $map :: (a 
\rightarrow b) \rightarrow [a] \rightarrow [b]$, transformująca zawartość listy 
z użyciem podanej funkcji mapującej, także nie zależy od zawartości listy. Nie 
oznacza to jednak, że podana funkcja mapująca i lista mogą mieć dowolny typ. 
Funkcja mapująca $(a \rightarrow b)$ musi przyjmować taki sam typ, jaki znajduje się w liście. W statycznie typowanym języku, kompilator, musi mieć 
pewność, że taki warunek zachodzi. Aby uniknąć powielania kodu, w większości języków funkcyjnych 
występuje \textit{let-polimorfizm}. 

Dzięki \textit{let-polimorfizmowi}, przy definicji funkcji, dany argument może 
mieć \newline ogólny typ, jeśli później w ciele tej funkcji, nie zostanie on
ukonkretniony. 
Wprowadzenie \textit{let-polimorfizmu} do języka, wymaga nie tylko jego obsługi 
w procesie generowania kodu (kompilacji), ale też przy etapie inferencji typów.
Każdy inferowany typ musi być najbardziej ogólny. W swoim kompilatorze 
zaimplementowałem oba te elementy. Omówię i porównam swoje rozwiązanie z rozwiązaniami występującymi w innych językach.

% TODO: Można rozszerzyć inferencje typów o let polimorfizm

\section{Rozwijanie funkcji oraz częściowa aplikacja}

// Co zrobiłem, po co, dlaczego
// co to {let polymorphism, type class}
% \section{Język ML}
% 1. Dlaczego ML, jakie są inne języki ML
% 2. Bazowanie na $ F\# $

% \chapter{Cechy języka $lang$}

// Cechy z przykładami

% \subsection{Składnia}

\chapter{Języka $lang$}

\subsection{Podstawowe wyrażania}

\subsection{Definicje funkcji}

\subsection{Rekordy}

\subsection{Klasy typów}

\subsection{Moduły}

\subsection{Tablice}

\subsection{Wołanie funkcji z $C$}

1. Opis, szczegóły składni, (przykłady: każda cecha języka i krótki przykład)

1. Proste wyrażenia, rekurencja, let-polymorphism, rekordy,
wzajemnie rekurencyjne funkcje na top levelu, klasy typów, proste moduły, 
wyrażanie na top levelu, efekty uboczne, inferencja typów, anotacje.

% \section{Klasy typów}

1. Wprowadzenie czym są 

2. Dlaczego? Jakie są alternatywy

3. Opis tego co zostało zaimplementowane, porównanie do innych języków, (Haskell,
Rust, Scala)

\chapter{Kompilator}
\section{Etapy kompilacji}

1. Jakie są etapy (lexer $\rightarrow$ parser $\rightarrow$ untyped ast $\rightarrow$ 
typed ast bez zagnieżdżonych funkcji $\rightarrow$ generowanie kodu (ast high-ollvm)
$\rightarrow$ wywoływanie funkcji z api llvma $\rightarrow$ llc $\rightarrow$ gcc i external) 

2. Krótko o każdym etapie

\section{Analiza leksykalna}

1. Czego użyłem. 

2. Analiza wcięć 

\section{Parsowanie}

1. Czego użyłem, coś o Menhirze, dlaczego Menhir 

2. Wyzwania (składnia bazująca na wcięciach)

3. Gramatyka

\section{Inferencja typów}

1. Po co? Jak działa u mnie

\section{Generowanie kodu}
\subsection{Częściowa aplikacja}

\subsection{Opis działania}

1. Dlaczego jest to nietrywialne

2. Jakie miałem cele 

3. Jak to działa u mnie 

4. Przykład (wygenerowanego pseudo-kodu)

\subsection{Porównanie z innymi implementacjami}

1. Push/enter vs eval/apply

Porównanie z pracą "Making a fast curry: ..."

\section{Zagnieżdżone funkcje}

1. Co to są zagnieżdżone funkcje 

2. Na czym polega trudność w ich implementacji 

3. Jak zostały zaimplementowane: lambda lifting + closure conversion + 
wykorzystanie aplikacji częściowej

\section{Rekordy}

Implementacja, porównanie do rekordów w F\#.

\section{Let polimorfizm}

1. Krótki opis, czym jest let-polimorfizm

2. Sposoby implementacji w różnych językach, zalety i wady 

3. Sposób implementacji u mnie

\section{Klasy typów}

1. Czym są? Po co? 

2. Sposoby implementowania, porównanie do pracy TODO

3. Jak zostały zaimplementowane, dlaczego tak

%%%%% BIBLIOGRAFIA

\begin{thebibliography}{1}

\bibitem{smlproposal} 
The Standard ML Core Language, by Robin Milner, July 1984.
\\\texttt{http://sml-family.org/history/SML-proposal-7-84.pdf}

\bibitem{modules_vs_typeclasses} 
ML Modules and Haskell Type Classes:
A Constructive Comparison
Stefan Wehr and Manuel M. T. Chakravarty
\\\texttt{https://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf}

\bibitem{no_hkt_in_rust} 
Higher kinded polymorphism - Rust Github issues.
\\\texttt{https://github.com/rust-lang/rfcs/issues/324}

\end{thebibliography}

\end{document}
