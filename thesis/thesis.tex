% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[declaration,shortabstract]{iithesis}

\usepackage[utf8]{inputenc}

\usepackage{listings}
% \usepackage{color}

% \definecolor{dkgreen}{rgb}{0,0.6,0}
% \definecolor{gray}{rgb}{0.5,0.5,0.5}
% \definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
%   numberstyle=\tiny\color{gray},
%   keywordstyle=\color{blue},
%   commentstyle=\color{dkgreen},
%   stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=true,
  tabsize=3
}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Implementacja języka funkcyjnego z rodziny ML z użyciem 
                 systemu kompilacji LLVM}
\englishtitle   {English title}
\polishabstract { TODO polish abstract}
\englishabstract{ TODO english abstract}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Mateusz Lewko}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr hab. Dariusz Biernacki}
\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
% \transcriptnum {283197}                     % Numer indeksu
%\advisorgen    {dr. Jana Kowalskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

\begin{document}

%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Wprowadzenie}

Pierwsze prace nad językiem ML zaczął Robin Milner na początku lat 70. W~1984, 
dzięki jego inicjatywie, powstał Standard ML - ustandaryzowana wersja języka ML.
Już wtedy zawierał m. in. rozwijanie funkcji, dopasowanie do wzorca, inferencje
typów oraz moduły parametryczne \cite{smlproposal}. Są to elementy, które cechują
większość dzisiejszych funkcyjnych języków programowania. Od tego czasu powstało 
wiele języków z rodziny ML. Jednymi z najpopularniejszych są: OCaml, F\# oraz 
dialekty SMLa. 

\section{Klasy typów}
Większość języków z rodziny ML w celu lepszego ustrukturyzowania
programu stosuje system modułów. Pozwala on na podzielenie programu na 
niezależne~od~siebie funkcjonalności.
Klasy typów, których głównym cele jest wprowadzenie 
ad-hoc polimorfizmu do języka, mogą po części także spełnić to zadanie 
\cite{modules_vs_typeclasses}. 
Są obecne w językach takich jak Haskell, Scala czy Rust. Fakt, że pojawiają się
w nowych językach ogólnego zastosowania, świadczy o ich atrakcyjności z punktu 
widzenia programisty. Mimo to nieznane są żadne popularne języki ML korzystającego
z tego rozwiązania. Jedynym z celów tej pracy jest wprowadzenie klas typów do 
prostego języka funkcyjnego, bazującego na podstawowych cechach rodziny ML. W tym 
celu stworzyłem kompilator języka $Lang$, wymyślonego na potrzeby tej pracy.

\section{Efektywna implementacja języka funkcyjnego}
Drugim celem tej pracy jest implementacja głównych cech języków funkcyjnych w
możliwie optymalny sposób. Skupię się na optymalizacji czasu wykonania programu,
 kosztem długości wygenerowanego kodu. Kompilacja będzie się odbywać do kodu 
maszynowego, gdyż daje to lepszą wydajność otrzymanego programu. Stanowi to też 
większe wyzwanie przy kompilacji języka funkcyjnego, niż napisanie interpretera, 
ze względu na jego wysoką poziomowość. Oczywiście, trudnym będzie uzyskanie 
podobnej lub lepszej wydajności niż popularne kompilatory języków funkcyjnych,
gdyż te stosują dużą liczbę skomplikowanych optymalizacji. Skupię się nad tym, 
aby moja implementacja prostego języka funkcyjnego, była porównywalna wydajnością 
z popularnymi rozwiązaniami. Omówię i porównam sposoby w jaki zdecydowałem się 
zaimplementować podstawowe cechy języków funkcyjnych, a w szczególności: częściową 
aplikację, zagnieżdżone funkcje, polimorfizm i klasy typów. Moje rozwiązania będą 
bazować na pomysłach z różnych języków programowania, w tym imperatywnych. Wspomniane 
cechy omówię dokładniej, ponieważ odbiegają od rozwiązań stosowanych w popularnych językach
funkcyjnych.

\section{Infrastruktura LLVM}
W celu uproszczeniu konstrukcji nowego kompilatora i ułatwienia pracy z generowaniem 
niskopoziomowego kodu, zdecydowałem się skorzystać z infrastruktury LLVM. Jest to zbiór 
narzędzi i bibliotek wykorzystywanych przez wiele współczesnych kompilatorów. LLVM dostarcza 
kompilator LLVM IR, który jest niskopoziomowym językiem stworzonym na potrzeby pisania 
kompilatorów. Przykładowy program napisany w LLVM IR:

% \lstset{language=llvm}
\begin{lstlisting}[frame=single]
@.str = internal constant [14 x i8] c"hello, world\0A\00"

declare i32 @printf(i8*, ...)

define i32 @main(i32 %argc, i8** %argv) nounwind {
entry:
    %tmp1 = getelementptr [14 x i8], [14 x i8]* @.str, i32 0, i32 0
    %tmp2 = call i32 (i8*, ...) @printf( i8* %tmp1 ) nounwind
    ret i32 0
}
\end{lstlisting}

LLVM IR składa się przede wszystkim z: deklaracji i definicji funkcji, zmiennych globalnych, 
podstawowych bloków, przypisań oraz wywołań funkcji. Podstawowe bloki kodu jak i funkcje nie 
mogą być zagnieżdżone. 

W moim kompilatorze nie generuję kodu LLVM'a, korzystam z oficjalnej biblioteki dla OCamla, 
udostępniającej interfejs potrzebny do tworzenia elementów wygenerowanego kodu. System LLVM 
jest odpowiedzialny za ostatni etap procesu kompilacji, zamianę kodu pośredniego (LLVM IR) na 
assembler. Cały kod jest w postaci Single Static Assignment, do jednej zmiennej (etykiety) 
można przypisać tylko jedno wyrażenie. Dzięki takiej formie kodu pośredniego, LLVM jest w 
stanie przeprowadzić na nim pewne optymalizacje, przed wygenerowaniem kodu maszynowego. 

\section{Klasy typów}

Jako pierwsze pojawiły się w języku Haskell. Początkowo zostały użyte w celu 
umożliwienia przeładowania operatorów arytmetycznych i równości. Od tego czasu, znaleziono dla nich więcej zastosowań w różnych językach programowania. 

Sposób ich użycia zaprezentuję na przykładzie języka Haskell. 
W celu stworzenia klasy typów $C$ dla typu ogólnego $a$, należy 
zdefiniować zbiór funkcji, które musi zawierać instancja tej klasy. Instancje 
klasy definiuje się dla typu konkretnego

// Co zrobiłem, po co, dlaczego
// co to {let polymorphism, type class}
\section{Język ML}
1. Dlaczego ML, jakie są inne języki ML
2. Bazowanie na $ F\# $


\chapter{Cechy języka $lang$}

// Cechy z przykładami


\subsection{Składnia}

1. Opis, szczegóły składni, (przykłady: każda cecha języka i krótki przykład)

\section{Cechy języka}

1. Proste wyrażenia, rekurencja, let-polymorphism, rekordy,
wzajemnie rekurencyjne funkcje na top levelu, klasy typów, proste moduły, 
wyrażanie na top levelu, efekty uboczne, inferencja typów, anotacje.

% \section{Klasy typów}

1. Wprowadzenie czym są 

2. Dlaczego? Jakie są alternatywy

3. Opis tego co zostało zaimplementowane, porównanie do innych języków, (Haskell,
Rust, Scala)

\section{Infrastruktura LLVM}

1. Co to jest? 

2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

3. Jak działa kompilowanie do LLVM? 

4. Krótki opis high-ollvm 

\chapter{Kompilator}
\section{Etapy kompilacji}

1. Jakie są etapy (lexer $\rightarrow$ parser $\rightarrow$ untyped ast $\rightarrow$ 
typed ast bez zagnieżdżonych funkcji $\rightarrow$ generowanie kodu (ast high-ollvm)
$\rightarrow$ wywoływanie funkcji z api llvma $\rightarrow$ llc $\rightarrow$ gcc i external) 

2. Krótko o każdym etapie

\section{Analiza leksykalna}

1. Czego użyłem. 

2. Analiza wcięć 

\section{Parsowanie}

1. Czego użyłem, coś o Menhirze, dlaczego Menhir 

2. Wyzwania (składnia bazująca na wcięciach)

3. Gramatyka

\section{Inferencja typów}

1. Po co? Jak działa u mnie

\section{Generowanie kodu}
\section{Częściowa aplikacja}

\subsection{Opis działania}

1. Dlaczego jest to nietrywialne

2. Jakie miałem cele 

3. Jak to działa u mnie 

4. Przykład (wygenerowanego pseudo-kodu)

\subsection{Porównanie z innymi implementacjami}

1. Push/enter vs eval/apply

Porównanie z pracą "Making a fast curry: ..."

\section{Zagnieżdżone funkcje}

1. Co to są zagnieżdżone funkcje 

2. Na czym polega trudność w ich implementacji 

3. Jak zostały zaimplementowane: lambda lifting + closure conversion + 
wykorzystanie aplikacji częściowej

\section{Rekordy}

Implementacja, porównanie do rekordów w F\#.

\section{Let polimorfizm}

1. Krótki opis, czym jest let-polimorfizm

2. Sposoby implementacji w różnych językach, zalety i wady 

3. Sposób implementacji u mnie

\section{Klasy typów}

1. Czym są? Po co? 

2. Sposoby implementowania, porównanie do pracy TODO

3. Jak zostały zaimplementowane, dlaczego tak

%%%%% BIBLIOGRAFIA

\begin{thebibliography}{1}

\bibitem{smlproposal} 
The Standard ML Core Language, by Robin Milner, July 1984.
\\\texttt{http://sml-family.org/history/SML-proposal-7-84.pdf}

\bibitem{modules_vs_typeclasses} 
ML Modules and Haskell Type Classes:
A Constructive Comparison
Stefan Wehr and Manuel M. T. Chakravarty
\\\texttt{https://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf}

\end{thebibliography}

\end{document}
