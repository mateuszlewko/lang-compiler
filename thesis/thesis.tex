% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[declaration,shortabstract]{iithesis}

% \usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[epsilon]{backnaur}
\usepackage{url}
% \usepackage{tikz}
% \usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
%     decorations.pathreplacing,decorations.pathmorphing,shapes,%
%     matrix,shapes.symbols}

% \usepackage{titlesec}
% \titlespacing*{\section}{0pt}{1.1\baselineskip}{\baselineskip}

% \usepackage{color}

% \definecolor{dkgreen}{rgb}{0,0.6,0}
% \definecolor{gray}{rgb}{0.5,0.5,0.5}
% \definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
%   numberstyle=\tiny\color{gray},
%   keywordstyle=\color{blue},
%   commentstyle=\color{dkgreen},
%   stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=true,
  tabsize=3
}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Implementacja języka funkcyjnego z rodziny ML z użyciem 
                 systemu kompilacji LLVM}
\englishtitle   {Implementation of ML-family functional language, using LLVM compiler infrastructure}
\polishabstract { TODO polish abstract}
\englishabstract{ TODO english abstract}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Mateusz Lewko}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr hab. Dariusz Biernacki}
\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
% \transcriptnum {283197}                     % Numer indeksu
%\advisorgen    {dr. Jana Kowalskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

% \newenvironment{bnfsplit}[1][0.3\textwidth]
%  {\minipage[t]{#1}$}
%  {$\endminipage}

\begin{document}
%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Wprowadzenie}

Pierwsze prace nad językiem ML zaczął Robin Milner na początku lat 70. W~1984, 
dzięki jego inicjatywie, powstał Standard ML - ustandaryzowana wersja języka ML.
Już wtedy zawierał m. in. rozwijanie funkcji, dopasowanie do wzorca, inferencje
typów oraz moduły parametryczne \cite{sml_proposal}. Są to elementy, które cechują
większość dzisiejszych funkcyjnych języków programowania. Od tego czasu powstało 
wiele języków z rodziny ML. Jednymi z najpopularniejszych są: OCaml, F\# oraz 
dialekty SMLa. 

\section{Klasy typów}
Większość języków z rodziny ML w celu lepszego ustrukturyzowania
programu stosuje system modułów. Pozwala on na podzielenie programu na 
niezależne~od~siebie funkcjonalności.
Klasy typów, których głównym cele jest wprowadzenie 
ad-hoc polimorfizmu do języka, mogą po części także spełnić to zadanie 
\cite{modules_vs_typeclasses}. 
Są obecne w językach takich jak Haskell, Scala czy Rust. Fakt, że pojawiają się
w nowych językach ogólnego zastosowania, świadczy o ich atrakcyjności z punktu 
widzenia programisty. Mimo to nieznane są żadne popularne języki ML korzystającego
z tego rozwiązania. Jedynym z celów tej pracy jest wprowadzenie klas typów do 
prostego języka funkcyjnego, bazującego na podstawowych cechach rodziny ML. W tym 
celu stworzyłem kompilator języka $Lang$, wymyślonego na potrzeby tej pracy.

\section{Efektywna implementacja języka funkcyjnego}
Drugim celem tej pracy jest implementacja głównych cech języków funkcyjnych w
możliwie optymalny sposób. Skupię się na optymalizacji czasu wykonania programu,
 kosztem długości wygenerowanego kodu. Kompilacja będzie się odbywać do kodu 
maszynowego, gdyż daje to lepszą wydajność otrzymanego programu. Stanowi to też 
większe wyzwanie przy kompilacji języka funkcyjnego, niż napisanie interpretera, 
ze względu na jego wysoką poziomowość. Oczywiście, trudnym będzie uzyskanie 
podobnej lub lepszej wydajności niż popularne kompilatory języków funkcyjnych,
gdyż te stosują dużą liczbę skomplikowanych optymalizacji. Skupię się nad tym, 
aby moja implementacja prostego języka funkcyjnego, była porównywalna wydajnością 
z popularnymi rozwiązaniami. Omówię i porównam sposoby w jaki zdecydowałem się 
zaimplementować podstawowe cechy języków funkcyjnych, a w szczególności: częściową 
aplikację, zagnieżdżone funkcje, polimorfizm i klasy typów. Moje rozwiązania będą 
bazować na pomysłach z różnych języków programowania, w tym imperatywnych. Wspomniane 
cechy omówię dokładniej, ponieważ odbiegają od rozwiązań stosowanych w popularnych językach
funkcyjnych.

\section{Infrastruktura LLVM}
% TODO: 
% 1. Co to jest? 

% 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

% 3. Jak działa kompilowanie do LLVM? 

% 4. Krótki opis high-ollvm 

W celu uproszczeniu konstrukcji nowego kompilatora i ułatwienia pracy z generowaniem 
niskopoziomowego kodu, zdecydowałem się skorzystać z infrastruktury LLVM. Jest to zbiór 
narzędzi i bibliotek wykorzystywanych przez wiele współczesnych kompilatorów. LLVM dostarcza 
kompilator LLVM IR, który jest niskopoziomowym językiem stworzonym na potrzeby pisania 
kompilatorów. Przykładowy program napisany w LLVM IR:

% \lstset{language=llvm}
\begin{lstlisting}[frame=single]
@.str = internal constant [14 x i8] c"hello, world\0A\00"

declare i32 @printf(i8*, ...)

define i32 @main(i32 %argc, i8** %argv) nounwind {
entry:
    %tmp1 = getelementptr [14 x i8], [14 x i8]* @.str, i32 0, i32 0
    %tmp2 = call i32 (i8*, ...) @printf( i8* %tmp1 ) nounwind
    ret i32 0
}
\end{lstlisting}

LLVM IR składa się przede wszystkim z: deklaracji i definicji funkcji, zmiennych globalnych, 
podstawowych bloków, przypisań oraz wywołań funkcji. Podstawowe bloki kodu jak i funkcje nie 
mogą być zagnieżdżone. 

W moim kompilatorze nie generuję kodu LLVM'a, korzystam z oficjalnej biblioteki dla OCamla, 
udostępniającej interfejs potrzebny do tworzenia elementów wygenerowanego kodu. System LLVM 
jest odpowiedzialny za ostatni etap procesu kompilacji, zamianę kodu pośredniego (LLVM IR) na 
assembler. Cały kod jest w postaci Single Static Assignment, do jednej zmiennej (etykiety) 
można przypisać tylko jedno wyrażenie. Dzięki takiej formie kodu pośredniego, LLVM jest w 
stanie przeprowadzić na nim pewne optymalizacje, przed wygenerowaniem kodu maszynowego. 

TODO: 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

\section{Klasy typów}

Jako pierwsze pojawiły się w języku Haskell. Początkowo zostały użyte w celu 
umożliwienia przeładowania operatorów arytmetycznych i równości. Od tego czasu, 
znaleziono dla nich więcej zastosowań w różnych językach programowania. W języku
Haskell, poza tym, że umożliwiają użycie przeładowanych funkcji, definiowania 
funkcjonalności wspólnej dla wielu typów (interfejsów), okazały się niezbędne 
do implementacji Monad. W języku systemowym Rust, odpowiednikiem klas typów są
$cechy$ (ang. trait). W podstawowych użyciach nie różnią się od klas typów, ale 
nie pozwalają na implementacje polimorfizmu wyższych rzędów \cite{no_hkt_in_rust} (ang. 
Higher-kinder polymorphism). Inną istotną różnicą jest fakt, że klasa typów z 
Haskella nie definiuje nowego typu, jedynie pozwala na ograniczenie typu do 
instancji klasy. $Cecha$ z Rusta może być użyta jak zwykły typ, przykładowo 
można stworzyć listę zawierające obiekty, które są różnymi instancjami 
(implementacjami) $cechy$. W Haskellu istnieją także rozszerzenia, które 
pozwalają na definicje klas z wieloma parametrami. 

% Jakich językach i czym się różnią

Istnieje wiele wariantów klas typów oraz rozwiązań do nich podobnych, dlatego w swoim kompilatorze zdecydowałem się zaimplementować ich najprostszą wersje, 
umożliwiającą $ad-hoc$ polimorfizm.

Podstawowe użycie klas typów zaprezentuję na przykładzie Haskella. 
W celu stworzenia klasy typów $C$ dla typu ogólnego $a$, należy 
zdefiniować zbiór funkcji, które musi zawierać instancja tej klasy. Dla danego 
typu i klasy może istnieć co najwyżej jedna instancja. 

% \lstset{language=llvm}
\begin{lstlisting}[frame=single, caption=Przykładowa definicja klasy typów.]
class Show a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
\end{lstlisting}

W powyższym przykładzie definiujemy klasę $Show$ zawierającą dwa operatory:~$==$ 
~oraz~$/=$. Powiemy, że typ ukonkretniony z $a$ jest instancją klasy $Show$, jeśli zawiera deklaracje obu funkcji z odpowiednimi typami. Przykładowa instancja dla typu $Bool$, mogłaby wyglądać następująco:

\begin{lstlisting}[frame=single, caption=Instancja klasy $Show$ dla typu $Bool$.]
instance Show Bool where
  True == True = True 
  False == False = True 
  _ == _ = False
  l /= r = not (l == r)
\end{lstlisting}

\section{Let-polimorfizm}

Istnieją funkcje, których implementacja jest taka sama, niezależenie od typu dla
którego ją aplikujemy. Przykładowo, funkcja obliczają długość generycznej listy 
nie zależy od typu elementów, które się w niej znajdują. Funkcja $map :: (a 
\rightarrow b) \rightarrow [a] \rightarrow [b]$, transformująca zawartość listy 
z użyciem podanej funkcji mapującej, także nie zależy od zawartości listy. Nie 
oznacza to jednak, że podana funkcja mapująca i lista mogą mieć dowolny typ. 
Funkcja mapująca $(a \rightarrow b)$ musi przyjmować taki sam typ, jaki znajduje się w liście. W statycznie typowanym języku, kompilator, musi mieć 
pewność, że taki warunek zachodzi. Aby uniknąć powielania kodu, w większości języków funkcyjnych 
występuje \textit{let-polimorfizm}. 

Dzięki \textit{let-polimorfizmowi}, przy definicji funkcji, dany argument może 
mieć \newline ogólny typ, jeśli później w ciele tej funkcji, nie zostanie on
ukonkretniony. 
Wprowadzenie \textit{let-polimorfizmu} do języka, wymaga nie tylko jego obsługi 
w procesie generowania kodu (kompilacji), ale też przy etapie inferencji typów.
Każdy inferowany typ musi być najbardziej ogólny. W swoim kompilatorze 
zaimplementowałem oba te elementy. Omówię i porównam swoje rozwiązanie z rozwiązaniami występującymi w innych językach.

% TODO: Można rozszerzyć inferencje typów o let polimorfizm

\section{Rozwijanie funkcji oraz częściowa aplikacja}

Częściowa aplikacja występuje wtedy, gdy po zaaplikowaniu mniejszej liczby 
argumentów niż wynosi arność funkcji, otrzymujemy nową funkcje. Przykładowo 
dla funkcji $f: (A \times B) \rightarrow C$ po zaaplikowaniu pierwszego 
argumentu $a : A$, otrzymujemy funkcję $g : B \rightarrow C$. W szczególności,
dla dowolnego $b : B$, zachodzi: $g(b) = f(a, b)$. Funkcja $g$, która jest 
częściowo zaaplikowaną funkcją $f$, musi zapamiętać zaaplikowane dotychczas 
argumenty. 

Częściowa aplikacja jest spotykana nie tylko w językach funkcyjnych. 
Przykładowo, biblioteka standardowa języka $\verb!C++!$ dostarcza funkcję
$bind$ \cite{cpp_bind}, która pozwala na zaaplikowanie części argumentów. 
Częściową aplikacje można osiągnąć poprzez rozwinięcie funkcji (ang. currying) 
do wielu funkcji jednoargumentowych. Na poniższym fragmencie kodu języka 
Javascript znajduje się przykład takiego rozwiązania.

% \lstset{language=javascript}
\begin{lstlisting}[frame=single, caption=Rozwinięcie funkcji w Javascriptcie.]
var add = x => (y => x + y);
var add3 = add(3);

console.log(add3(12)); // 15
console.log(add(3)(12)); // 15
\end{lstlisting}

Javascript nie jest językiem funkcyjnym, a funkcje w nim zdefiniowane są w 
zwiniętej formie. Z tego powodu konieczne jest zastosowanie rozwlekłej składni, 
takiej jak w ostatniej linii przytoczonego przykładu. Ta sama funkcja 
zdefiniowana w OCamlu wygląda następująco:

\begin{lstlisting}[frame=single, caption=Rozwinięta funkcja w OCamlu.]
let add x y = x + y 
print_int (add 3 12)
\end{lstlisting}

Funkcja $add$ w języku w OCaml jest już w postaci rozwiniętej, więc jej 
deklaracja i wywołanie mają bardziej atrakcyjną formę, niż w poprzednim 
przykładzie. Dlatego zdecydowałem się ją zaimplementować.

W praktyce taka metoda realizacji częściowej aplikacji, jak pokazałem na 
przykładzie Javascriptu, byłaby niepotrzebnie nieefektywna. Bardziej optymalny,
ale też i złożony sposób obsługi aplikacji częściowej, który zastosowałem w tym 
kompilatorze, zaprezentuję w~rozdziale poświęconym jego implementacji.

% // Co zrobiłem, po co, dlaczego
% // co to {let polymorphism, type class}
% \section{Język ML}
% 1. Dlaczego ML, jakie są inne języki ML
% 2. Bazowanie na $ F\# $

% \chapter{Cechy języka $lang$}
% \subsection{Składnia}

\chapter{Język $lang$}

\section{Inspiracja}
Składnia języka $lang$ jest w większości zapożyczona z języka $F\#$, należącego
do rodziny ML. Dzięki zastosowaniu składni czułej na wcięcia, która eliminuje 
konieczność użycia wielu słów kluczowych, jest jednym z  prostszych języków z 
tej rodziny. Przy tworzeniu nowego języka funkcyjnego, kierowałem się głównie 
jego prostotą. Poza zapożyczeniem składni $F\#$ dla podstawowych wyrażeń, 
funkcji i typów rozszerzyłem ją o wyrażenia koniecznie do realizacji klas typów
i ich instancji.
% Jedną z najpopularniejszych funkcjonalności, zasugerowaną przez użytkowników, są
% typy klas \cite{fslang_typeclass}. 
% To było jedną inspiracją do całego projektu 
% i dodania tego elementu do jednego z 

\section{Podstawowe wyrażania}

\subsection{Wyrażenia warunkowe}

Składnia wyrażeń warunkowych jest bardzo podobna do tej w $F\#$. W języku $Lang$
istnieją jednak pewne uproszczenia względem $F\#$. 
Warunek musi być prostym wyrażeniem zawierającym operacje arytmetyczne i logiczne
oraz wywołania funkcji. Nie może zawierać przykładowo: wielolinijkowych wyrażeń
$if$ i wyrażeń $let$. Ciało warunku może być złożonym wyrażeniem, takim jak 
ciało funkcji, o ile występuje w nowej lini i jest wcięte bardziej niż 
token $if$. TODO: Więcej o wcięciach
Poniższa gramatyka, prezentują zbliżoną formę do rzeczywistej składni języka.
Dokładny opis gramatyki znajduje się w pliku 
\path{lang-compiler/compiler/parsing/grammar.mly}. Jest bardziej skomplikowany
ze względu na rozpoznawanie bloków kodu z takim samym poziomem wcięcia na
poziomie parsera. Lepszym pod względem czytelności, jest wykonanie tej 
czynności na etapie lexera, tak jak to ma miejsce w $F\#$. Dokładniejszy opis 
sposobu parsowania składni bazującej na wcięciach, w tym i innych językach,
znajduje się w rozdziale TODO: rozdział. 

Dla prostoty zapisu przyjąłem że:
\begin{enumerate}
  \item * to wystąpienie poprzedzającego wyrażenia zero lub więcej razy,
  \item + to wystąpienie poprzedzającego wyrażenia jeden lub więcej razy.
\end{enumerate}

\begin{bnf*}
  \bnfprod{simple-if-exp}
    { \bnfts{ if } \bnfpn{simple-exp} \bnfts{ then } \bnfpn{simple-exp} 
      \bnfpn{simple-elif-exp} \bnfpn{simple-else-exp}
    }\\
  \bnfprod{if-exp}
    { \bnfts{ if } \bnfpn{simple-exp} \bnfpn{newline} \bnfts{ then } 
      \bnfpn{body-exp}+ \bnfpn{elif-exp}\ast \bnfpn{else-exp}
    }\\
  \bnfprod{simple-else-exp}
    {\bnfts{ else } \bnfpn{simple-exp} \bnfor \bnfes}\\
  \bnfprod{simple-elif-exp}
    {\bnfts{ elif } \bnfpn{simple-exp} \bnfts{ then } \bnfpn{simple-exp} \bnfor \bnfes}\\
  \bnfprod{elif-exp}
    {\bnfts{ elif } \bnfpn{body-exp}+ \bnfor \bnfpn{simple-elif-exp} 
     \bnfor \bnfes}\\
  \bnfprod{else-exp}
    {\bnfts{ else } \bnfpn{body-exp}+ \bnfor \bnfpn{simple-else-exp} 
     \bnfor \bnfes}\\
  \bnfprod{newline}
    {\bnftd{nowa linia}}
\end{bnf*}

\subsection{Wyrażenia arytmetyczne i logiczne}
Wyrażenia arytmetyczne i logiczne mają taką samą składnię jak w pozostałych
językach z rodziny ML.
\begin{bnf*}
  \bnfprod{bool-exp}
    { \bnfpn{simple-exp} \bnfpn{bool-op} \bnfpn{simple-exp} 
    }\\
  \bnfprod{arith-exp}
    { \bnfpn{simple-exp} \bnfpn{arith-op} \bnfpn{arith-exp} 
    }\\
  \bnfprod{arith-op}
    { \bnfts{+} \bnfor \bnfts{-} \bnfor \bnfts{*}
      \bnfor \bnfts{/} 
    }\\
  \bnfprod{bool-op}
    { \bnfts{\&\&} \bnfor \bnfts{$\|$} 
    }\\
\end{bnf*}

\section{Deklaracja funkcji (wyrażenie let)}

Argumenty funkcji muszą być w tym samym wierszu co słowo $let$. Po znaku 
$=$, ciało może być złożonym wyrażeniem o ile zaczyna się w następnym wierszu i 
jest w późniejszej kolumnie niż słowo $let$. Wyrażenie $let$ może być 
zdefiniowane w jednej linii, o ile jego ciało jest pojedyńczym wyrażeniem prostym.

TODO: Let z argumentami z adnotacjami.
TODO: Rekurencja

\begin{bnf*}
  \bnfprod{let-exp}
    { \bnfts{let} \bnfpn{identifier}+ \bnfts{=} \bnfpn{simple-exp} 
      \bnfor \bnfts{let} \bnfpn{identifier}+ \bnfts{=} 
      \bnfpn { newline } \bnfpn{body-exp}
    }\\
\end{bnf*}

\subsection{Wzajemnie rekurencyjne wyrażenia let}

TODO: 

% \begin{grammar}
% \begin{lstlisting}
% % <expression> ::= ['$+$' | '$-$'] <term> \{('$+$' | '$-$' ) <term>\}

% % <term> ::= <factor>* \{('$*$' | '$/$') <factor>\}

% % <factor> ::= "number" | <identifier>  | '(' <expression> ')'
% \end{lstlisting}
% \end{grammar}

\section{Rekordy}

\subsection{Deklaracja rekordu}

\begin{bnf*}
  \bnfprod{record-decl}
    { \bnfts{type} \bnfpn{identifier} \bnfts{=} \bnfts{'\{'} 
      \bnfpn{field-decl}+ \bnfts{'\}'} 
    }\\
  \bnfprod{field-decl}
    { \bnfpn{identifier} \bnfts{:} \bnfpn{identifier}+
      \bnfpn{newline} \bnfor \bnfpn{identifier} \bnfts{:} \bnfpn{identifier}+
      \bnfts{;}
    }\\
\end{bnf*}

\subsection{Literał rekordu}

Literał może być zdefiniowany w jednym lub wielu wierszach. W przypadku 
definicji w jednym wierszu, kolejne pola muszą być oddzielone średnikami. 
Średnik może być pominięty jeśli kolejne pola są oddzielone nową linią. 
Dle definicji wielowierszowej, klamra otwierająca i zamykająca muszą być w tej 
samej kolumnie.

\begin{bnf*}
\bnfprod{record-lit}
  { \bnfts{ type } \bnfpn{identifier} \bnfts{=} \bnfts{'\{'} 
    \bnfpn{field-lit}+ \bnfts{'\}'} 
  }\\
\bnfprod{field-lit}
  { \bnfpn{identifier} \bnfts{ = } \bnfpn{simple-exp}
    \bnfpn{newline} \bnfor \bnfpn{identifier} \bnfts{ = } \bnfpn{simple-exp}
    \bnfts{ ; }
  }\\
\end{bnf*}

\subsection{Uaktualnianie rekordu}

Rekordy w $Langu$, podobnie jak rekordy w $F\#$ i OCamlu, są trwałe. 
Uaktualnienie jednego z pól skutkuje stworzeniem nowego rekordu. Dlatego to
wyrażenie ma inną składnię niż ta znana z języków imperatywnych.

\begin{bnf*}
\bnfprod{record-update}
  { \bnfts{ \{ } \bnfpn{simple-exp} \bnfts{ with } 
    \bnfpn{field-update}+ \bnfts{ \} } 
  }\\
\bnfprod{field-update}
  { \bnfpn{identifier} \bnfts{=} \bnfpn{simple-exp}
    \bnfpn{newline} \bnfor \bnfpn{identifier} \bnfts{=} \bnfpn{simple-exp}
    \bnfts{;}
    TODO: samo pole 
  }\\
\end{bnf*}

\section{Klasy typów}

Jako, że w językach z rodziny ML nie występują klasy typów, ich składnie 
zdecydowałem się zapożyczyć z Haskella.

\subsection{Deklaracja klasy}

\subsection{Deklaracja instancji}

\section{Moduły}

Moduły w $Langu$ spełniają takie zadanie jak te w $F\#$ -- służą jako 
przestrzeń nazw dla związanych ze sobą definicji. Nie są odpowiednikiem 
systemu dużo bardziej zaawansowanych modułów SMLa czy OCamla.
Moduł zawiera: wyrażenia let, zagnieżdżone moduły, import innych 
modułów oraz deklaracje funkcji zewnętrznych. Nazwa modułu musi się zaczynać 
z wielkiej litery. 

TODO: Gramatyka modułu

\section{Tablice}

Zaimplementowane zostały jedynie tablice zawierające typ $int$. Tablice są 
ulotną strukturą danych. Na poziomie języka można stworzyć literał tablicy.
Zmiana i odczytanie komórki tablicy, bądź utworzenie niezainicjalizowanej tablicy odbywa się poprzez zewnętrzne funkcje zaimplementowane $C$. Tablice w 
langu są reprezentowane tak samo jak języku w $C$, jako spójny ciąg w pamięci.

Elementami literału tablicy, mogą być proste wyrażenia, oddzielone średnikiem. 
Podobnie jak w \newline $OCamlu$ i $F\#$ tablica zaczyna się od symbolu $[|$, a kończy symbolem $|]$.

\textbf{Uwaga.} Dla wielowierszowego literału tablicy, symbol rozpoczynający 
$[|$ i kończący $|]$, muszą być w tej samej kolumnie.

\section{Wołanie funkcji z $C$}

Mała część funkcjonalności języka została zaimplementowana z użyciem 
zewnętrznych funkcji w $C$ (wypisywanie oraz operacje na tablicy). Dlatego 
koniecznym było dołożenie wyrażeń pozwalających zadeklarować zewnętrzny symbol 
wraz z jego typem. Ich składnia jest prawie taka sama jak w OCamlu. Typy 
$Langa$ są dosłownie tłumaczone na typy w $C$, z wyjątkiem typu $unit$, który jest zamieniany na $bool$ (o rozmiarze jeden bajt).

TODO: Gramatyka external

% 1. Opis, szczegóły składni, (przykłady: każda cecha języka i krótki przykład)

% 1. Proste wyrażenia, rekurencja, let-polymorphism, rekordy,
% wzajemnie rekurencyjne funkcje na top levelu, klasy typów, proste moduły, 
% wyrażanie na top levelu, efekty uboczne, inferencja typów, anotacje.

% % \section{Klasy typów}

% 1. Wprowadzenie czym są 

% 2. Dlaczego? Jakie są alternatywy

% 3. Opis tego co zostało zaimplementowane, porównanie do innych języków, (Haskell,
% Rust, Scala)

\chapter{Kompilator}
\section{Etapy kompilacji}

Cały proces kompilacji, od momentu wczytania pliku z kodem źródłowym, do 
wyprodukowania pliku wykonywalnego, składa się z następujących etapów:
\begin{enumerate}
  \item Analiza leksykalna, w efekcie której otrzymujemy ciąg tokenów.
  TODO: w jakim pliku.
  \item Otrzymany ciąg jest następnie poddany analizie składniowej 
  (ang. parsing), która zgodnie z podaną gramatyką generuje \textit{drzewo 
  składni abstrakcyjnej (ang. abstract syntax tree)}. Węzły tego drzewa 
  zawierają jedno z wyrażeń, lecz nie posiadają informacji o typie tego
  wyrażenia. TODO: W jakim pliku.
  \item Następnie, wykonywana jest transformacja drzewa składni, która:

  \begin{enumerate}
    \item Dzięki przeprowadzeniu inferencji typów, nadaje każdemu wyrażeniu jego typ z języka $Lang$ (na późniejszym etapie, wyrażenia będą miał typ 
    z \textit{LLVM IR}). 
    \item Eliminuje zagnieżdżone wyrażenia $let$.
    \item Eliminuje moduły oraz otwarcia modułów poprzez translacje symboli do 
    ich w pełni kwalifikowanych nazw (ang. fully qualified name).
  \end{enumerate}

  \item Generowanie drzewa wyrażeń z LLVM IR. Jest to największy etap z całego 
  procesu kompilacji. Zamienia skomplikowane wyrażenia wysokopoziomowego języka
  na proste wyrażenia LLVM IR, które już łatwo mogą być przetłumaczone na 
  niskopoziomowe instrukcje.

  \item Konwersja drzewa wyrażeń LLVM IR na kod LLVM IR. Odbywa się to dzięki 
  interfejsowi programistycznemu (ang. api), udostępnionym przez oficjalną 
  bibliotekę LLVM dla $OCamla$.

\end{enumerate}

% 1. Jakie są etapy (lexer $\rightarrow$ parser $\rightarrow$ untyped ast $\rightarrow$ 
% typed ast bez zagnieżdżonych funkcji $\rightarrow$ generowanie kodu (ast high-ollvm)
% $\rightarrow$ wywoływanie funkcji z api llvma $\rightarrow$ llc $\rightarrow$ gcc i external) 

% 2. Krótko o każdym etapie

\section{Analiza leksykalna}

Do przeprowadzania analizy leksykalnej skorzystałem z biblioteki 
\textit{sedlex}. Jest to generator lekserów dla języka OCaml.

\subsection{Analiza wcięć}
 
Istnieje wiele języków programowania, realizujących ideę składni czułej na 
wcięcia. Sposób w jaki działa to w $F\#$ jest jednym z bardziej zaawansowanych,
bo pozwala na zdefiniowanie wielowierszowych aplikacji funkcji, warunków itp., 
bez użycia znaków przełamania wiersza bądź słów kluczowych znanych 
z języka OCaml (\textit{begin}, \textit{end}, \textit{;}). W $F\#$ istnieje 
także możliwość mieszania tych słów kluczowych z wcięciami. 

Analiza wcięć w $Langu$ jest zbliżona do tej w \textit{Pythonie}
\cite{python_indentation}. Dla każdego wiersza, 
na bieżąco jest obliczany numer kolumny pierwszego znaku (wcięcie). Długości 
wcięć z poprzednich wierszy są trzymane na stosie. Na początku na stosie
znajduję się wcięcie długości 0. Gdy wcięcie w obecnym wierszu jest większe od 
ostatniego na stosie, generowany jest token \textit{INDENT}, oznaczający 
początek wciętego bloku. Gdy wcięcie jest mniejsze od ostatniego na stosie, 
wszystkie większe są zdejmowane ze stosu i dla każdego zdjętego, generowany 
jest token \textit{DEDENT}. Oznacza on koniec wciętego bloku. Po zdjęciu 
wszystkich większych wcięć, ostatnie wcięcie, które zostanie na stosie musi być 
równe obecnemu wcięciu, w szczególności może być równe $0$. W przeciwnym 
przypadku, kod źródłowy jest źle wcięty i kompilator zwróci błąd.

\section{Parsowanie}

Popularnym narzędziem do generowania parserów jest \textit{Menhir}. Na 
\newline podstawie podanej gramatyki \textit{LR(1)}, generuje kod $OCamla$, 
który ją parsuje. Częściowo wspiera składnię \textit{EBNF}, m. in. operatory: $
+$, $?$, $\ast$. Zdecydowałem się skorzystać z tego narzędzia ze względu na 
łatwość użycia, możliwość interaktywnego debugowania gramatyki oraz 
ekspresywność składni w porównaniu do podobnych narzędzi takich jak \textit
{ocamlyacc}. Całość gramatyki znajduje się w pliku 
\path{lang-compiler/compiler/parsing/grammar.mly}. 
TODO: Może coś o kontekstach w F\#

% \section{Generowanie kodu}
\section{Częściowa aplikacja i funkcje}

Jak wspomniałem we wprowadzeniu, generowanie wszystkich funkcji w rozwiniętej 
formie (każda funkcja przyjmuje tylko jeden argument) jest nieoptymalne pod
względem długości kodu jak i szybkości jego wykonania. Pomimo że, aplikacja 
częściowa jest bardzo przydatną cechą języków funkcyjnych, to często funkcje
wywoływane są ze wszystkimi argumentami. W takich przypadkach chcielibyśmy 
korzystać z wywołania funkcji, które jest tak szybkie jak w \textit{C}. 
W kompilatorze \textit{Langa} pracowałem nad rozwiązaniem, które w pozostałych 
przypadkach korzystałoby z przekazywania argumentów funkcji przez rejestry i 
pozwalałoby na przekazywanie typów o różnych rozmiarach przez wartość. 

\subsection{Opis działania}

Podzielmy wszystkie wywołania funkcji na dwie grupy. Wywołania do znanych 
(ang. known call) i nie znanych funkcji (ang. unknown call). Znane funkcje to 
takie, których definicję można łatwo wskazać na etapie kompilacji. 
Na poniższym przykładzie, wywołana funkcja TODO: jest statycznie znana.

\begin{lstlisting}[frame=single, caption=Wywołanie statycznie znanej funkcji.]
TODO: Known call example
\end{lstlisting}

Przykładem nieznanych funkcji są funkcje, które: 
\begin{itemize}
  \item zostały podane jako argument,
  \item są wynikiem wywołania funkcji,
  \item są wynikiem częściowej aplikacji funkcji.
\end{itemize}

W tym przykładzie wywołane funkcje $a$, $b$ i $c$ są nieznane.

\begin{lstlisting}[frame=single, caption=Przykłady statycznie 
nieznanej funkcji.]
TODO: Unknown call example
\end{lstlisting}

\subsubsection{Wywołanie funkcji znanej}

Gdy funkcja, którą chcemy wywołać jest znana, możemy wyróżnić trzy przypadki 
ze względu na liczbę zaaplikowanych argumentów względem liczby argumentów
w definicji funkcji.

\begin{enumerate}
  \item Liczba zaaplikowanych argumentów jest mniejsza od liczby zdefiniowanych 
  argumentów. W tym przypadku utworzony zostaje obiekt reprezentujący częściowo
  zaaplikowaną funkcję. Zostaną w nim zapisane zaaplikowane argumenty oraz 
  wskaźnik na odpowiednią funkcję. Skopiowane argumenty i sam obiekt zostaną 
  utworzone na stercie.
  \item Zaaplikowanych argumentów jest tyle co zdefiniowanych. Funkcja zostanie
  wywołana w stylu z $C$. Jest to najbardziej optymalny przypadek wywołania 
  funkcji i nie powoduje on zaalokowania żadnej dodatkowej pamięci. Jeśli 
  początkowe argumenty mieszczą się w rejestrach to mogą zostać przez nie 
  przekazane.
  \item Zaaplikowanych argumentów może być więcej niż zdefiniowanych jeśli wynikiem wywoływanej funkcji jest funkcja. Niech $n$ to będzie liczba 
  zdefiniowanych argumentów. Najpierw nastąpi wywołanie znanej funkcji z 
  pierwszymi $n$ argumentami. Do wyniku pierwszego wywołania, który teraz jest
  nieznaną funkcją, zostaną zaaplikowane pozostałe argumenty. W tym momencie 
  zastosowany zostanie jeden z przypadków dla wywołań nieznanych funkcji.

TODO: Coś o tym że funkcje / symbole trzymane są w środowisku z informacją 
known / unknown.
\end{enumerate}

\subsubsection{Wywołanie funkcji nieznanej}

Wywołania funkcji nieznanych podzielimy na takie, których wynikiem jest dowolna
funkcja $ a \rightarrow b $ i takie których wynikiem jest wartość. Podczas
fazy inferencji typów, obliczany jest typ każdego wyrażenia, więc kompilator
jest w stanie określić do której grupy należy dana aplikacja funkcji. Każda 
nieznana lub częściowo zaaplikowana funkcja jest reprezentowana przez strukturę 
(taką jak w $C$), 
zawierającą następujące pola:

\begin{itemize}
  \item wskaźnik na funkcje,
  \item wskaźnik na środowisko (zapamiętane argumenty), które jest pamiętane 
  jako spójny ciąg bajów. TODO: Można też tablice wskaźników na argumenty i 
  dlaczego tak nie zrobiłem
  \item liczba bajtów w środowisku,
  \item liczba obecnie zaaplikowanych argumentów
  \item pozostała liczba argumentów koniecznych do zaaplikowana, aby należało 
  wywołać wskazywaną funkcje.
\end{itemize}

Definicja takiej struktury w $C$ wyglądałaby następująco:

\begin{lstlisting}[frame=single, caption=Rozwinięta funkcja w OCamlu.]
struct function {
    void (*fn)();
    unsinged char *args;
    unsinged char left_args;
    unsinged char arity;
    int used_bytes;   
};
\end{lstlisting}

Wskaźnik na funkcje \textit{fn}, przed wywołaniem musi zostać zrzutowany na 
prawidłowy typ. Dla aplikacji funkcji, których wynikiem jest funkcja, typ 
wynikowy funkcji \textit{fn} to struktura \textit{function}. Jako argumenty 
funkcji \textit{fn}, poza argumentami podanymi w aplikacji funkcji, przekazane 
zostaną dodatkowo: wskaźnik na środowisko i liczba aplikowanych argumentów.
Funkcja wołana jest odpowiedzialna za nadmiarowe argumenty i przekazanie ich 
dalej.

Aplikacja funkcji nie zawsze musi się wiązać z faktycznym wywołaniem funkcji.
Na poniższym przykładzie w pierwszym przypadku funkcja \textit{TODO:}
zostanie wywołana, a w drugim, pomimo aplikacji tych samych argumentów, nic nie 
zostanie wywołane.
\begin{lstlisting}[frame=single, caption={To czy funkcja zostanie wywołana,
nie jest wiadome w czasie kompilacj.}]
TODO: Przykład z wywołaniem i nie wywołaniem częściowo 
zaaplikowanej funkcji  
\end{lstlisting}

Dla każdego wywołania nieznanej funkcji, generowany jest dodatkowy \newline
kod, który jest odpowiedzialny za sprawdzenie, czy aplikowaną funkcje 
faktycznie trzeba wywołać, czy jedynie zapisać dodatkowe argumenty do 
środowiska. Aby to sprawdzić, porównywana jest liczba argumentów pozostałych do 
wywołania funkcji (\textit{left\_args}) z liczbą zaaplikowanych argumentów.
Jeśli liczba pozostałych argumentów jest większa, to wszystkie argumenty 
zostaną skopiowane do pola \textit{args} w strukturze \textit{function}, a 
odpowiednie jej pola uaktualnione.

% TODO: o dynamicznych przypadkach

% TODO: wywoływanie funkcji, przypadki z przykładami
TODO: Przykład w pseudokodzie? Może algorytm

% TODO: Co to unknown i know call 

TODO: generowanie każdej funkcji


% 1. Dlaczego jest to nietrywialne

% 2. Jakie miałem cele 

% 3. Jak to działa u mnie 

% 4. Przykład (wygenerowanego pseudo-kodu)

\subsubsection{Generowanie funkcji}

Jednym z założeń implementacji tego języka, była możliwość przekazywania typów
o różnym rozmiarze, przez ich wartość a nie przez wskaźnik. W obecnej 
implementacji istnieje tylko kilka typów o różnej długości: \textit{bool},
\textit{int} i \textit{rekord}. Rekordy mają taki sam rozmiar, ponieważ są 
przekazywane przez wskaźnik do ich zawartości zapamiętanej na stercie, ale 
łatwo rozszerzyć język o typy o dowolnej długości. 

Takie założenie komplikuje implementację częściowej aplikacji funkcji. Aby 
zrozumieć dlaczego, weźmy dwie instancje struktury \textit{function}, dla 
funkcji o typie \textit{int $\rightarrow$ bool $\rightarrow$ int 
$\rightarrow$ bool}. Niech pierwsza zostanie częściowo zaaplikowana dwoma 
argumentami o typach \textit{int} i \textit{bool}, a druga pierwszym argumentem
o typie \textit{int}. W kolejnym kroku, chcąc wywołać obie funkcje, do 
pierwszej struktury aplikujemy pozostały argument o typie \textit{int}, a do 
drugiej pozostałe dwa o typach \textit{bool} i \textit{int}. Wskaźnik \textit
{fn} z pierwszej struktury zostałby zrzutowany na wskaźnik na funkcję 
przyjmującą jako pierwszy argument zmienną typu \textit{int}, a funkcja 
wskazywana przez \textit{fn} z drugiej struktury przyjmowałaby jako pierwszy 
argument typ \textit{bool}. Nie można dopuścić do takiej sytuacji. Nasuwa się 
możliwe rozwiązanie, w którym w momencie gdy dochodzi do wywołania funkcji (co 
może być sprawdzone w czasie działania programu dzięki polu 
\textit{left\_args}) można przekazać wszystkie argumenty znajdujące sie w 
środowisku. Wtedy typ zrzutowanych funkcji wskazywanych przez \textit{fn} byłby 
taki sam, niezależnie od tego ile dotychczas argumentów zostało zaaplikowanych.
Jednak, argumenty w środowisku są zapamiętane przez wartość w tablicy, \textit
{args} a ich reprezentacja nie jest jednorodna, co uniemożliwia ich przekazanie.
Jednorodną reprezentacje wszystkich argumentów można uzyskać poprzez 
reprezentowanie ich przez wskaźnik, ale takiego rozwiązania chciałem uniknąć.
Innym sposobem byłoby zapamiętanie wszystkich argumentów, także tych 
aplikowanych jako ostatnie, w środowisku. Wywoływana funkcja, wie już w czasie 
kompilacji jakich argumentów (i o jakim rozmiarze), spodziewać się w środowisku,
więc jest w stanie je z niego odzyskać. To rozwiązanie rozwiązuje wspomniany 
problem, lecz wykonuje niepotrzebne zapisywanie i ładowanie argumentów 
zaaplikowanych jako ostatnie. Moje rozwiązanie unika tej operacji. 

W tym celu, poza generowaniem właściwej funkcji, generowane są także funkcje 
wejściowe (ang. entry point), które będą używane w przypadku wywoływania 
nieznanej funkcji. 
Funkcja wejściowa przyjmuje: 
\begin{itemize}
  \item wskaźnik na środowisko \textit{unsigned char$\ast$},
  \item liczbę przekazywanych argumentów \textit{unsigned char} 
  (obsługiwane jest maksymalnie 255 argumentów),
  \item część argumentów oryginalnej funkcji.
\end{itemize}
Załóżmy, że oryginalna funkcja ma typ: $a_1 \rightarrow a_2 \rightarrow ...
\rightarrow a_n \rightarrow t$. Wtedy, dla takiej funkcji zostanie wygenerowanych $n$ funkcji 
wejściowych, gdzie $i-ta$ funkcja będzie przyjmowała sufiks ciągu oryginalnych
argumentów, od $i-tego$ argumentu. Jeśli funkcja oryginalna zwraca funkcję to 
jej argumenty także będą uwzględnione w funkcji wejściowej.

Dla oryginalnej funkcji, tworzona jest globalna tablica wskaźników na wszystkie 
jej funkcje wejściowe. Funkcje są zapamiętane po kolei, tj. 
wskaźnik na pierwszą funkcję wejściową jest pierwszym elementem tablicy, na 
drugą, drugim itd. 
Gdy tworzona jest instancja struktury \textit{function}, jak wskaźnik na 
funkcję do wywołania ustawiany jest wskaźnik na początek tablicy funkcji 
wejściowych. Oznacza to, że typ pola \textit{fn} w języku \textit{C} to 
\textit{void ($\ast\ast$fn)()}, oraz że przed wywołaniem funkcji ze struktury,
należy zdereferować (ang. dereference) wskaźnik. Wskaźnik na wołaną funkcją 
musi być w każdym momencie programu aktualny, tzn musi odpowiadać liczbie 
początkowych argumentów zapamiętanych w środowisku. Dlatego gdy kolejne 
argumenty są aplikowane, wskaźnik jest zwiększany. 

% \subsubsection{Funkcje wejściowe}
% TODO: Ciało funkcji wejściowych

Funkcje wejściowe są odpowiedzialne za odczytanie argumentów ze środowiska i 
przekazanie ich do wywołania oryginalnej funkcji. Jeśli wynikiem funkcji 
oryginalnej jest funkcja, następuje jeden z dwóch przypadków sprawdzanych w
czasie działania programu.

\begin{enumerate}
  \item Nie ma pozostało więcej argumentów do zaaplikowania, 
  funkcja wyjściowa jako swój wynik może zwrócić wynik funkcji oryginalnej.
  \item Pozostałych argumentów jest mniej lub tyle samo niż wynosi 
  wartość pola \textit{left\_args} ze struktury otrzymanej jako wynik 
  pierwszego wywołania.
  Należy zapisać pozostałe argumenty do środowiska i uaktualnić pola struktury 
  \textit{function}.
\end{enumerate}

Po wywołaniu funkcji należy jeszcze sprawdzić czy nie została zwrócona 
struktura, którą od razu można wywołać (taka która ma pole \textit{left\_args} 
równe $0$). Taki wynik mógł powstać w funkcji wołanej w drugim przypadku.

\subsection{Porównanie z innymi implementacjami}

1. Push/enter vs eval/apply

Porównanie z pracą "Making a fast curry: ..."

\section{Zagnieżdżone funkcje}

Zagnieżdżone funkcje są nieodłączną częścią języków funkcyjnych. Ich implementacja wykorzystuje 
\textit{closure conversion}, które zostało wykorzystane przy częściowej aplikacji funkcji. 
Ideą \textit{closure conversion} jest pamiętanie funkcji wraz z jej domknięciem. 
\textit{Closure conversion} dodaje duży narzut pamięciowy i czasowy na wygenerowany program,
dlatego należy ustalić dlaczego taka operacja jest potrzebna.

Zdefiniujmy funkcje \textit{make\_adder} w \textit{OCamlu}, która będzie zwracać zagnieżdżona funkcje.
Ciało zagnieżdżonej funkcji \textit{add} odwołuje się do zmiennej z zewnętrznego zakresu.

\begin{lstlisting}[frame=single, caption={Zagnieżdżona funkcja w \textit{OCamlu}}]
let make_adder x = 
    let add y = x + y in 
    add 
  
let _ = 
    let add1 = make_adder 1 in 
    let add5 = make_adder 5 in 
    
    print_int (add1 1);
    print_int (add5 5) 
\end{lstlisting}
Powyższy kod wypisze wynik działań $1 + 1$ oraz $5 + 5$. 

Niskopoziomowy język, taki jaki \textit{LLVM IR} nie obsługuje zagnieżdżonych funkcji, można w
nim zadeklarować jedynie procedury na takim samym, najwyższym poziomie (ang. top level). 
Konieczna jest transformacja wyrażeń \textit{let}, polegająca na przeniesieniu ich na najwyższy poziom. 
Jeśli wykonamy taką transformacje na funkcji \textit{add}, bez dodatkowych zmian, to zmienna $x$,
przesanie być dostępna z ciała funkcji.

\begin{lstlisting}[frame=single, caption={Po przeniesieniu funkcji \textit{add} na najwyższy poziom}]
let add y = x + y 
let make_adder x = add 
\end{lstlisting}

Powyższy kod nie jest poprawnym programem w języku \textit{OCaml}, oraz 
nie mógbły zostać poprawnie przetłumaczony na kod \textit{LLVM IR}. 
Skoro $x$ jest poza zasięgiem ciała \textit{add}, można zaproponować rozwiązanie w którym 
wprowadzona zostaje globalna zmienna, odpowiadająca zmiennej wolnej $x$. 
Na poniższym przykładzie zostało przedstawione jak mogłaby wyglądać taka transformacja.

\begin{lstlisting}[frame=single, caption={Wprowadzenie globalnej zmiennej.}]
let global_x = ref 0

let add y = !x + y 
let make_adder x = 
    global_x := x
    add 
\end{lstlisting}
Powyższe przekształcenia nie wprowadzają dużego narzutu na wynikowy program i rozwiązują 
problem z zasięgiem symbolu $x$. Ten kod jednak nie zwróci poprawnego wyniku, przy założeniu o statycznym zasięgu widoczności (ang. static scoping). Drugie 
wywołanie \textit{make\_adder} dla argumentu 5, nadpisze jego pierwszą wartość z której korzysta
pierwsze wywołanie funkcji \textit{add1}. Koniecznym jest zapamiętanie $x$ w środowisku funkcji 
\textit{add}, w momencie w którym jest zwracana. 

W \textit{Langu}, do implementacji \textit{closure conversion} postanowiłem wykorzystać,
już zaimplementowaną częściową aplikację. W czasie analizy programu dla każdego 
zagnieżdżonego wyrażenia \textit{let} wyznaczam jego zmienne wolne. Zmienne wolne
zostaną dodane jako dodatkowe argumenty, przed tymi podanymi pierwotnie.
Następnie, symbol pod którym wyrażenie \textit{let} było zapamiętane w 
środowisku, zostaje związany z częściową aplikacją zmienny wolnych 
do oryginalnej funkcji (rozszerzonej o dodatkowe argumenty -- zmienne wolne).
Poniżej została na funkcji \textit{add} została wykonana ta transformacja.

\begin{lstlisting}[frame=single, caption={Wprowadzenie globalnej zmiennej.}]
let make_adder x = 
    let add_extended_with_free_vars x y = x + y
    let add = add_extended_with_free_vars x

    add
\end{lstlisting}

Po tym etapie, funkcję \textit{add\_extended\_with\_free\_vars} można przenieść 
na najwyższy poziom (\textit{lambda lifting}). \textit{add} jest teraz zwykłym 
przypisaniem wyrażenia do zmiennej, więc może być łatwo przetłumaczone na 
niskopoziomowy kod.

% 1. Co to są zagnieżdżone funkcje 

% 2. Na czym polega trudność w ich implementacji

% 3. Jak zostały zaimplementowane: lambda lifting + closure conversion + 
% wykorzystanie aplikacji częściowej

\section{Rekordy}

Rekordy są podstawowym sposobem na tworzenie własnych typów danych w wielu 
językach programowania. Do \textit{Langa} zostały wprowadzone głównie po ty, 
aby urozmaicić przykłady zastosowania klas typów. 

Jako że LLVM IR wspiera struktury, które są odpowiednikiem implementowanych 
rekordów, dodanie ich do języka nie stanowiło problemu. W obecnej 
implementacji 
wszystkie struktury alokowane są na stercie i przekazywane przez wskaźnik.
Pola struktury są pamiętane przez ich wartość, chyba że polem jest inna 
struktura. Są trwałym typem danych, więc aktualizacja pól struktury 
z wyrażeniem \textit{with}, powoduje skopiowane jej zawartości do nowej 
instancji.

\section{Let polimorfizm}

% 1. Krótki opis, czym jest let-polimorfizm

Bez let polimorfizmu, którego odpowiednikiem w językach imperatywnych jest 
polimorfizm parametryczny, ciężko wyobrazić sobie nowoczesny język. 
Mimo wygody jaką dostarcza programiście, często wiąże sie z dodatkowym
obciążeniem czasowym i pamięciowym. Polimorficzna funkcja 
\lstinline[language=Caml]!let identity x = x! może być użyta niezależenie
od typu podanego argumentu. Jednak, jeśli funkcja \textit{identity} 
jest aplikowana do argumentów typu \textit{int} i textit{float}, to nie jest 
jasne jak powinien wyglądać jej wygenerowany kod. Argument typu \textit{float}
zostałby przekazany przez specjalny rejestr dla liczb zmiennoprzecinkowych, 
inny od tego dla argumentu typu \textit{int}. W wygenerowanym kodzie jasno
należy określić jaki wariant będzie wspierać dana funkcja. Dlatego wiele 
języków rozwiązuje ten problem poprzez jednorodną reprezentację wszystkich 
typów, które mogą być użyte w funkcjach polimorficznych. Jednorodna 
reprezentacja sprowadza się do alokowania wartości obiektu na stercie, a 
następnie przekazywanie wskaźnika na ten obiekt. Wszystkie wskaźniki 
niezależnie od typu i rozmiaru obiektu na który wskazują, mają ten sam 
rozmiar i są przekazywane w ten sam sposób. Niesie to ze sobą kilka wad.
Przykładowo, dla każdego \textit{inta} który sam zajmuje $4$ bajty,
dodatkowo alokowane jest $8$ bajtów na wskaźnik do niego. Jako, że jest 
zaalokowany na stercie, będzie musiał być ręcznie zwolniony przez programistę 
lub przez automatyczne odśmiecanie pamięci (które często występuje w językach 
funkcyjnych).

Do języków które stosują powyższą metodę należą m. in. Java i Haskell.
W Haskellu konieczna jest taka reprezentacja danych także ze względu na jego 
leniwość. Dostępne w nim są także prymitywne typy reprezentowane przez 
ich wartość (ang. unboxed types), takie jak \textit{\#Int} i 
\textit{\#Double}. Jednak nie mogą być one użyte w funkcjach polimorficznych. 
W fazie optymalizacji, kompilator \textit{GHC} może zamienić typ boxed 
na unboxed, ale nie jest to gwarantowane. Jako że kierowałem się wydajnością
przy implementacji kompilatora \textit{Langa}, to rozwiązanie nie jest 
satysfakcjonujące.

\textit{OCaml} reprezentuje \textit{inty} i wskaźniki na jednym słowie 
maszynowym. To czy do funkcji został przekazany wskaźnik czy \textit{int}
przez wartość jest rozpoznawane na podstawie najniższego bitu, który jest 
traktowany jak znacznik. Jeśli wynosi $1$ to dana wartość jest \textit{intem}.
To rozwiązania pozwala na uniknięcie większości narzutu przy wykonywaniu 
operacji na typach prymitywnych, ale wiąże się z niestandardowym podejście do 
arytmetyki liczb i wciąż nie pozwala na przekazywanie przez wartość obiektów 
dłuższych niż słowo maszynowe. W związku ze wspominanymi wadami tego 
rozwiązania, nie zdecydowałem sie go zaimplementować.

Języki takie jak \textit{C++} i \textit{Rust} oraz kompilator \textit{SMLa} 
MLton, wyspecjalizowują każdą polimorficzną funkcję przed fazą generowania 
kodu. Ten proces nazywany jest monomorfizacją. Polega on na utworzenia osobnej 
implementacji polimorficznej funkcji dla każdego konkretnego typu który został 
podstawiony pod typ ogólny. W \textit{C++} użytkownik może explicite podać 
dla jakich typów ukonkretnia daną funkcje, bądź może być to wykryte przez 
kompilator.

\begin{lstlisting}[frame=single, caption={Polimorficzna funkcja w 
\textit{C++} z użyciem szablonów (ang. template)}]
template<class Type1, class Type2>
void foo(Type1 t1, Type2 t2) {
    // ...
}

int main() {
    foo<std::string, int>("hello world", 42);
    foo("hello world2", 24);
    foo(1.0, 4.0);
}
\end{lstlisting}

Dla funkcji \textit{foo} z powyższego przykładu zostaną wygenerowane dwie 
implementacje, a oryginalne wywołania funkcji zostaną już w fazie kompilacje
zamienione na wywołania odpowiednich, wyspecjalizowanych wersji tej funkcji.
Takie rozwiązanie pozwala na przekazanie dowolnego typu przez jego wartość, 
bez zmian jego reprezentacji. Jednak nie jest ono pozbawione kompromisów. 
Statyczna monomorfizacja funkcji, nie pozwala na zastosowanie polimorficznej
rekurencji. Dodatkowo, zwiększa długość wygenerowanego kodu, tym samym 
wydłużając czas kompilacji i zwiększać rozmiar wynikowego programu. Kolejną 
wadą w praktycznych zastosowaniach, jest fakt, że wysokopoziomowy kod 
implementacji funkcji polimorficznej musi być opublikowany wraz z wygenerowaną 
bibliotekę, aby istniała możliwość użycia wywołania tej funkcji dla typów dla 
których nie byłą wcześniej ukonkretniona. Mimo to, język \textit{C++} cieszy 
się ogromną popularnością, a system szablonów jest szeroko używany, także w 
zastosowaniach produkcyjnych. 

W \textit{Langu} postanowiłem zaimplementować rozwiązanie bazujące na 
monomorfizacji. Jest ono zgodne z założeniami projektu oraz dobrze współgra z 
pozostałymi rozwiązaniami. W trakcie inferencji typów każda polimorficzna 
funkcja z \textit{Langa} jest reprezentowana w kompilatorze jako funkcja z 
ukonkretnień typów ogólnych w implementację. Gdy w fazie generacji kodu 
dochodzi do wywołania funkcji polimorficznej, muszą być znane wszystkie 
ukonkretnienia. Wtedy wywoływana jest funkcja generująca implementację na 
podstawie typów konkretnych. Implementacje funkcji dla tych samych typów 
konkretnych są zapamiętywane.

% znanej funkcji jest zapamiętywane dla jakich typów została ukonkretniona. 
% Następnie w fazie generowania kodu, dla każdego różnego zbioru ukonkretnień 
% typów ogólnych, tworzona jest odpowiednia implementacja funkcji. Programista 
% nie wybiera, która implementacja

% 2. Sposoby implementacji w różnych językach, zalety i wady 
% 3. Sposób implementacji u mnie

\section{Inferencja typów}

Inferencja typów zwalnia programistę z obowiązku wyspecyfikowania typów 
każdej deklaracji, pozostawiając wszystkie zalety statycznego systemu typów.
W \textit{Langu} działa ona następująco. Na początku każdemu argumentowi,
który nie został oznaczony przez użytkownika typem konkretny, zostaje 
przypisany różny typ ogólny. Podczas inferencji w ciele funkcji, dla 
każdego wyrażenia, dla którego może być wywnioskowane jakieś ograniczenie 
(np. warunek w \textit{if} powinien mieć typ \textit{bool}), odpowiednia 
równość między typami zostaje zapisana w drzewie ast tej funkcji. Po 
przetworzeniu funkcji, zostaje zbudowany graf równości między typami. 
Sprawdzane jest czy któreś argumenty w ciele funkcji zostały ukonkretnione, 
jeśli tak to definicja funkcji jest aktualizowana, jeśli nie to typ pozostaje
ogólny. Graf równości typów jest także używany w celu znalezienia konkretnych 
typów przy wywoływaniu polimorficznej funkcji (dzieję się to w fazie 
generowania kodu). 
TODO: O optymalizacji z union finda.

\section{Klasy typów}

% 1. Czym są? Po co? 

Najpopularniejszą implementacją klas typów, jest ta zastosowana w Haskellu. 
Jej idea polega na przekazywaniu słownika (rekordu) z implementacjami funkcji 
z danej instancji klasy (ang. dictionary passing). Przedstawię w jaki sposób 
działa ta implementacja, porównując kod używający klas typów w Haskellu i 
odpowiadający mu kod w OCamlu (w którym nie ma klas typów).

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Deklaracja klasy typów w Haskellu, frame=tlrb]{Name}
class Show a where 
    show :: a -> String
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Deklracja odpowiednika klasy typów w OCamlu z
użyciem metody przekazywania słownika, frame=tlrb]{Name}
type 'a show = { 
    show : 'a -> string 
} 
\end{lstlisting}
\end{minipage}

W przypadku Haskella zdefiniowaliśmy klasę typów \textit{Show} z metodą 
\textit{show} o typie $a \rightarrow String$. W przypadku \textit
{OCamla} musieliśmy stworzyć polimorficzny rekord z jednym polem \textit{show}.
Instancja tego rekordu będzie instancją tej klasy dla danego typu. 

Na poniższym przykładzie w OCamlu, obie instancje \textit{Show}, zwracają 
rekord z odpowiednimi implementacjami zapisanymi w polach rekordu. 

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Instancja klasy w Haskellu, frame=tlrb]{Name}
instance Show String where
    show s = "'" ++ s ++ "'"

instance Show Bool where
    show True = "true"
    show False = "false" 

\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Instancja klasy w OCamlu, frame=tlrb]{Name}
let show_string = {
    show = fun s -> "'" ^ s ^ "'"
}

let show_bool = {
    show = function 
           | false -> "false"
           | true  -> "true"
}

\end{lstlisting}
\end{minipage}

Funkcja, która korzysta z typu który jest instancją klasy, musi przyjmować 
dodatkowy argument będą słownikiem z implementacją metod klasy. 

\noindent\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Instancja klasy w Haskellu, frame=tlrb]{Name}
printArg :: Show a => a -> IO ()
printArg arg = 
    putStrLn ("arg: " ++ show arg)

main1 = printArg True
main2 = printArg "Hello World"
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\begin{lstlisting}[caption=Instancja klasy w OCamlu, frame=tlrb]{Name}
let printArg show_instance arg = 
    show_instance.show arg
    |> printf "arg: %s" 

let main1 = 
    printArg show_bool true 

let main2 = 
    printArg show_string "Hello"
\end{lstlisting}
\end{minipage}

Zasadnicza różnica między symulowaniem klas typów w języku ich nie 
wspierającym, a użyciem ich w Haskellu, jest to, że to do użytkownika należy 
udowodnienie istnienia instancji klasy dla danego typu.

TODO: O tym że to może być bardziej uciążliwe \newline
jak są klasy bazowe: 
http://okmij.org/ftp/Computation/typeclass.html

Metoda przekazywania słownika nie niesie ze sobą dużego narzutu na czas 
kompilacji i wykonywania programu. Co prawda wymaga 

% 2. Sposoby implementowania, porównanie do pracy TODO

% 3. Jak zostały zaimplementowane, dlaczego tak

\chapter{Podsumowanie}

\section{Wnioski}

\section{Dalsze prace}

\chapter{Instrukcja obsługi}

\section{Instalacja}

\section{Sposób użycia z przykładami}

\section{Użyte narzędzia i biblioteki}

\section{Struktura projektu}

%%%%% BIBLIOGRAFIA

\begin{thebibliography}{1}

\bibitem{sml_proposal} 
The Standard ML Core Language, by Robin Milner, July 1984.
\\\texttt{http://sml-family.org/history/SML-proposal-7-84.pdf}

\bibitem{modules_vs_typeclasses} 
ML Modules and Haskell Type Classes:
A Constructive Comparison
Stefan Wehr and Manuel M. T. Chakravarty
\\\texttt{https://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf}

\bibitem{no_hkt_in_rust} 
Higher kinded polymorphism - Rust Github issues.
\\\texttt{https://github.com/rust-lang/rfcs/issues/324}

\bibitem{cpp_bind} 
std::bind - C++ Reference
\\\texttt{https://en.cppreference.com/w/cpp/utility/functional/bind}

\bibitem{fslang_typeclass} 
TODO: FS lang, user voice - type classes
\\\texttt{https://fslang.uservoice.com/forums/245727-f-language/filters/top}

\bibitem{python_indentation} 
Indentation. Python Reference Manual.
\\\texttt{https://docs.python.org/2.5/ref/indentation.html}

\bibitem{levity_polymorphism} 
Levity Polymorphism.
\\\texttt{https://www.microsoft.com/en-us/research/wp-content/\newline
uploads/2016/11/levity-pldi17.pdf}


\end{thebibliography}

\end{document}
