% Opcje klasy 'iithesis' opisane sa w komentarzach w pliku klasy. Za ich pomoca
% ustawia sie przede wszystkim jezyk i rodzaj (lic/inz/mgr) pracy, oraz czy na
% drugiej stronie pracy ma byc skladany wzor oswiadczenia o autorskim wykonaniu.
\documentclass[declaration,shortabstract]{iithesis}

% \usepackage{syntax}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[epsilon]{backnaur}
\usepackage{url}
% \usepackage{tikz}
% \usetikzlibrary{calc,trees,positioning,arrows,chains,shapes.geometric,%
%     decorations.pathreplacing,decorations.pathmorphing,shapes,%
%     matrix,shapes.symbols}

% \usepackage{titlesec}
% \titlespacing*{\section}{0pt}{1.1\baselineskip}{\baselineskip}

% \usepackage{color}

% \definecolor{dkgreen}{rgb}{0,0.6,0}
% \definecolor{gray}{rgb}{0.5,0.5,0.5}
% \definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
%   numberstyle=\tiny\color{gray},
%   keywordstyle=\color{blue},
%   commentstyle=\color{dkgreen},
%   stringstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=true,
  tabsize=3
}

%%%%% DANE DO STRONY TYTUŁOWEJ
% Niezaleznie od jezyka pracy wybranego w opcjach klasy, tytul i streszczenie
% pracy nalezy podac zarowno w jezyku polskim, jak i angielskim.
% Pamietaj o madrym (zgodnym z logicznym rozbiorem zdania oraz estetyka) recznym
% zlamaniu wierszy w temacie pracy, zwlaszcza tego w jezyku pracy. Uzyj do tego
% polecenia \fmlinebreak.
\polishtitle    {Implementacja języka funkcyjnego z rodziny ML z użyciem 
                 systemu kompilacji LLVM}
\englishtitle   {Implementation of ML-family functional language, using LLVM compiler infrastructure}
\polishabstract { TODO polish abstract}
\englishabstract{ TODO english abstract}
% w pracach wielu autorow nazwiska mozna oddzielic poleceniem \and
\author         {Mateusz Lewko}
% w przypadku kilku promotorow, lub koniecznosci podania ich afiliacji, linie
% w ponizszym poleceniu mozna zlamac poleceniem \fmlinebreak
\advisor        {dr hab. Dariusz Biernacki}
\date          {}                     % Data zlozenia pracy
% Dane do oswiadczenia o autorskim wykonaniu
% \transcriptnum {283197}                     % Numer indeksu
%\advisorgen    {dr. Jana Kowalskiego} % Nazwisko promotora w dopelniaczu
%%%%%

%%%%% WLASNE DODATKOWE PAKIETY
%
%\usepackage{graphicx,listings,amsmath,amssymb,amsthm,amsfonts,tikz}
%
%%%%% WŁASNE DEFINICJE I POLECENIA
%
%\theoremstyle{definition} \newtheorem{definition}{Definition}[chapter]
%\theoremstyle{remark} \newtheorem{remark}[definition]{Observation}
%\theoremstyle{plain} \newtheorem{theorem}[definition]{Theorem}
%\theoremstyle{plain} \newtheorem{lemma}[definition]{Lemma}
%\renewcommand \qedsymbol {\ensuremath{\square}}
% ...
%%%%%

% \newenvironment{bnfsplit}[1][0.3\textwidth]
%  {\minipage[t]{#1}$}
%  {$\endminipage}

\begin{document}
%%%%% POCZĄTEK ZASADNICZEGO TEKSTU PRACY

\chapter{Wprowadzenie}

Pierwsze prace nad językiem ML zaczął Robin Milner na początku lat 70. W~1984, 
dzięki jego inicjatywie, powstał Standard ML - ustandaryzowana wersja języka ML.
Już wtedy zawierał m. in. rozwijanie funkcji, dopasowanie do wzorca, inferencje
typów oraz moduły parametryczne \cite{sml_proposal}. Są to elementy, które cechują
większość dzisiejszych funkcyjnych języków programowania. Od tego czasu powstało 
wiele języków z rodziny ML. Jednymi z najpopularniejszych są: OCaml, F\# oraz 
dialekty SMLa. 

\section{Klasy typów}
Większość języków z rodziny ML w celu lepszego ustrukturyzowania
programu stosuje system modułów. Pozwala on na podzielenie programu na 
niezależne~od~siebie funkcjonalności.
Klasy typów, których głównym cele jest wprowadzenie 
ad-hoc polimorfizmu do języka, mogą po części także spełnić to zadanie 
\cite{modules_vs_typeclasses}. 
Są obecne w językach takich jak Haskell, Scala czy Rust. Fakt, że pojawiają się
w nowych językach ogólnego zastosowania, świadczy o ich atrakcyjności z punktu 
widzenia programisty. Mimo to nieznane są żadne popularne języki ML korzystającego
z tego rozwiązania. Jedynym z celów tej pracy jest wprowadzenie klas typów do 
prostego języka funkcyjnego, bazującego na podstawowych cechach rodziny ML. W tym 
celu stworzyłem kompilator języka $Lang$, wymyślonego na potrzeby tej pracy.

\section{Efektywna implementacja języka funkcyjnego}
Drugim celem tej pracy jest implementacja głównych cech języków funkcyjnych w
możliwie optymalny sposób. Skupię się na optymalizacji czasu wykonania programu,
 kosztem długości wygenerowanego kodu. Kompilacja będzie się odbywać do kodu 
maszynowego, gdyż daje to lepszą wydajność otrzymanego programu. Stanowi to też 
większe wyzwanie przy kompilacji języka funkcyjnego, niż napisanie interpretera, 
ze względu na jego wysoką poziomowość. Oczywiście, trudnym będzie uzyskanie 
podobnej lub lepszej wydajności niż popularne kompilatory języków funkcyjnych,
gdyż te stosują dużą liczbę skomplikowanych optymalizacji. Skupię się nad tym, 
aby moja implementacja prostego języka funkcyjnego, była porównywalna wydajnością 
z popularnymi rozwiązaniami. Omówię i porównam sposoby w jaki zdecydowałem się 
zaimplementować podstawowe cechy języków funkcyjnych, a w szczególności: częściową 
aplikację, zagnieżdżone funkcje, polimorfizm i klasy typów. Moje rozwiązania będą 
bazować na pomysłach z różnych języków programowania, w tym imperatywnych. Wspomniane 
cechy omówię dokładniej, ponieważ odbiegają od rozwiązań stosowanych w popularnych językach
funkcyjnych.

\section{Infrastruktura LLVM}
% TODO: 
% 1. Co to jest? 

% 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

% 3. Jak działa kompilowanie do LLVM? 

% 4. Krótki opis high-ollvm 

W celu uproszczeniu konstrukcji nowego kompilatora i ułatwienia pracy z generowaniem 
niskopoziomowego kodu, zdecydowałem się skorzystać z infrastruktury LLVM. Jest to zbiór 
narzędzi i bibliotek wykorzystywanych przez wiele współczesnych kompilatorów. LLVM dostarcza 
kompilator LLVM IR, który jest niskopoziomowym językiem stworzonym na potrzeby pisania 
kompilatorów. Przykładowy program napisany w LLVM IR:

% \lstset{language=llvm}
\begin{lstlisting}[frame=single]
@.str = internal constant [14 x i8] c"hello, world\0A\00"

declare i32 @printf(i8*, ...)

define i32 @main(i32 %argc, i8** %argv) nounwind {
entry:
    %tmp1 = getelementptr [14 x i8], [14 x i8]* @.str, i32 0, i32 0
    %tmp2 = call i32 (i8*, ...) @printf( i8* %tmp1 ) nounwind
    ret i32 0
}
\end{lstlisting}

LLVM IR składa się przede wszystkim z: deklaracji i definicji funkcji, zmiennych globalnych, 
podstawowych bloków, przypisań oraz wywołań funkcji. Podstawowe bloki kodu jak i funkcje nie 
mogą być zagnieżdżone. 

W moim kompilatorze nie generuję kodu LLVM'a, korzystam z oficjalnej biblioteki dla OCamla, 
udostępniającej interfejs potrzebny do tworzenia elementów wygenerowanego kodu. System LLVM 
jest odpowiedzialny za ostatni etap procesu kompilacji, zamianę kodu pośredniego (LLVM IR) na 
assembler. Cały kod jest w postaci Single Static Assignment, do jednej zmiennej (etykiety) 
można przypisać tylko jedno wyrażenie. Dzięki takiej formie kodu pośredniego, LLVM jest w 
stanie przeprowadzić na nim pewne optymalizacje, przed wygenerowaniem kodu maszynowego. 

TODO: 2. Dlaczego LLVM i jakie są inne opcje (C, asembler)? 

\section{Klasy typów}

Jako pierwsze pojawiły się w języku Haskell. Początkowo zostały użyte w celu 
umożliwienia przeładowania operatorów arytmetycznych i równości. Od tego czasu, 
znaleziono dla nich więcej zastosowań w różnych językach programowania. W języku
Haskell, poza tym, że umożliwiają użycie przeładowanych funkcji, definiowania 
funkcjonalności wspólnej dla wielu typów (interfejsów), okazały się niezbędne 
do implementacji Monad. W języku systemowym Rust, odpowiednikiem klas typów są
$cechy$ (ang. trait). W podstawowych użyciach nie różnią się od klas typów, ale 
nie pozwalają na implementacje polimorfizmu wyższych rzędów \cite{no_hkt_in_rust} (ang. 
Higher-kinder polymorphism). Inną istotną różnicą jest fakt, że klasa typów z 
Haskella nie definiuje nowego typu, jedynie pozwala na ograniczenie typu do 
instancji klasy. $Cecha$ z Rusta może być użyta jak zwykły typ, przykładowo 
można stworzyć listę zawierające obiekty, które są różnymi instancjami 
(implementacjami) $cechy$. W Haskellu istnieją także rozszerzenia, które 
pozwalają na definicje klas z wieloma parametrami. 

% Jakich językach i czym się różnią

Istnieje wiele wariantów klas typów oraz rozwiązań do nich podobnych, dlatego w swoim kompilatorze zdecydowałem się zaimplementować ich najprostszą wersje, 
umożliwiającą $ad-hoc$ polimorfizm.

Podstawowe użycie klas typów zaprezentuję na przykładzie Haskella. 
W celu stworzenia klasy typów $C$ dla typu ogólnego $a$, należy 
zdefiniować zbiór funkcji, które musi zawierać instancja tej klasy. Dla danego 
typu i klasy może istnieć co najwyżej jedna instancja. 

% \lstset{language=llvm}
\begin{lstlisting}[frame=single, caption=Przykładowa definicja klasy typów.]
class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
\end{lstlisting}

W powyższym przykładzie definiujemy klasę $Eq$ zawierającą dwa operatory:~$==$ 
~oraz~$/=$. Powiemy, że typ ukonkretniony z $a$ jest instancją klasy $Eq$, jeśli zawiera deklaracje obu funkcji z odpowiednimi typami. Przykładowa instancja dla typu $Bool$, mogłaby wyglądać następująco:

\begin{lstlisting}[frame=single, caption=Instancja klasy $Eq$ dla typu $Bool$.]
instance Eq Bool where
  True == True = True 
  False == False = True 
  _ == _ = False
  l /= r = not (l == r)
\end{lstlisting}

\section{Let-polimorfizm}

Istnieją funkcje, których implementacja jest taka sama, niezależenie od typu dla
którego ją aplikujemy. Przykładowo, funkcja obliczają długość generycznej listy 
nie zależy od typu elementów, które się w niej znajdują. Funkcja $map :: (a 
\rightarrow b) \rightarrow [a] \rightarrow [b]$, transformująca zawartość listy 
z użyciem podanej funkcji mapującej, także nie zależy od zawartości listy. Nie 
oznacza to jednak, że podana funkcja mapująca i lista mogą mieć dowolny typ. 
Funkcja mapująca $(a \rightarrow b)$ musi przyjmować taki sam typ, jaki znajduje się w liście. W statycznie typowanym języku, kompilator, musi mieć 
pewność, że taki warunek zachodzi. Aby uniknąć powielania kodu, w większości języków funkcyjnych 
występuje \textit{let-polimorfizm}. 

Dzięki \textit{let-polimorfizmowi}, przy definicji funkcji, dany argument może 
mieć \newline ogólny typ, jeśli później w ciele tej funkcji, nie zostanie on
ukonkretniony. 
Wprowadzenie \textit{let-polimorfizmu} do języka, wymaga nie tylko jego obsługi 
w procesie generowania kodu (kompilacji), ale też przy etapie inferencji typów.
Każdy inferowany typ musi być najbardziej ogólny. W swoim kompilatorze 
zaimplementowałem oba te elementy. Omówię i porównam swoje rozwiązanie z rozwiązaniami występującymi w innych językach.

% TODO: Można rozszerzyć inferencje typów o let polimorfizm

\section{Rozwijanie funkcji oraz częściowa aplikacja}

Częściowa aplikacja występuje wtedy, gdy po zaaplikowaniu mniejszej liczby 
argumentów niż wynosi arność funkcji, otrzymujemy nową funkcje. Przykładowo 
dla funkcji $f: (A \times B) \rightarrow C$ po zaaplikowaniu pierwszego 
argumentu $a : A$, otrzymujemy funkcję $g : B \rightarrow C$. W szczególności,
dla dowolnego $b : B$, zachodzi: $g(b) = f(a, b)$. Funkcja $g$, która jest 
częściowo zaaplikowaną funkcją $f$, musi zapamiętać zaaplikowane dotychczas 
argumenty. 

Częściowa aplikacja jest spotykana nie tylko w językach funkcyjnych. 
Przykładowo, biblioteka standardowa języka $\verb!C++!$ dostarcza funkcję
$bind$ \cite{cpp_bind}, która pozwala na zaaplikowanie części argumentów. 
Częściową aplikacje można osiągnąć poprzez rozwinięcie funkcji (ang. currying) 
do wielu funkcji jednoargumentowych. Na poniższym fragmencie kodu języka 
Javascript znajduje się przykład takiego rozwiązania.

% \lstset{language=javascript}
\begin{lstlisting}[frame=single, caption=Rozwinięcie funkcji w Javascriptcie.]
var add = x => (y => x + y);
var add3 = add(3);

console.log(add3(12)); // 15
console.log(add(3)(12)); // 15
\end{lstlisting}

Javascript nie jest językiem funkcyjnym, a funkcje w nim zdefiniowane są w 
zwiniętej formie. Z tego powodu konieczne jest zastosowanie rozwlekłej składni, 
takiej jak w ostatniej linii przytoczonego przykładu. Ta sama funkcja 
zdefiniowana w OCamlu wygląda następująco:

\begin{lstlisting}[frame=single, caption=Rozwinięta funkcja w OCamlu.]
let add x y = x + y 
print_int (add 3 12)
\end{lstlisting}

Funkcja $add$ w języku w OCaml jest już w postaci rozwiniętej, więc jej 
deklaracja i wywołanie mają bardziej atrakcyjną formę, niż w poprzednim 
przykładzie. Dlatego zdecydowałem się ją zaimplementować.

W praktyce taka metoda realizacji częściowej aplikacji, jak pokazałem na 
przykładzie Javascriptu, byłaby niepotrzebnie nieefektywna. Bardziej optymalny,
ale też i złożony sposób obsługi aplikacji częściowej, który zastosowałem w tym 
kompilatorze, zaprezentuję w~rozdziale poświęconym jego implementacji.

% // Co zrobiłem, po co, dlaczego
% // co to {let polymorphism, type class}
% \section{Język ML}
% 1. Dlaczego ML, jakie są inne języki ML
% 2. Bazowanie na $ F\# $

% \chapter{Cechy języka $lang$}
% \subsection{Składnia}

\chapter{Język $lang$}

\section{Inspiracja}
Składnia języka $lang$ jest w większości zapożyczona z języka $F\#$, należącego
do rodziny ML. Dzięki zastosowaniu składni czułej na wcięcia, która eliminuje 
konieczność użycia wielu słów kluczowych, jest jednym z  prostszych języków z 
tej rodziny. Przy tworzeniu nowego języka funkcyjnego, kierowałem się głównie 
jego prostotą. Poza zapożyczeniem składni $F\#$ dla podstawowych wyrażeń, 
funkcji i typów rozszerzyłem ją o wyrażenia koniecznie do realizacji klas typów
i ich instancji.
% Jedną z najpopularniejszych funkcjonalności, zasugerowaną przez użytkowników, są
% typy klas \cite{fslang_typeclass}. 
% To było jedną inspiracją do całego projektu 
% i dodania tego elementu do jednego z 

\section{Podstawowe wyrażania}

\subsection{Wyrażenia warunkowe}

Składnia wyrażeń warunkowych jest bardzo podobna do tej w $F\#$. W języku $Lang$
istnieją jednak pewne uproszczenia względem $F\#$. 
Warunek musi być prostym wyrażeniem zawierającym operacje arytmetyczne i logiczne
oraz wywołania funkcji. Nie może zawierać przykładowo: wielolinijkowych wyrażeń
$if$ i wyrażeń $let$. Ciało warunku może być złożonym wyrażeniem, takim jak 
ciało funkcji, o ile występuje w nowej lini i jest wcięte bardziej niż 
token $if$. TODO: Więcej o wcięciach
Poniższa gramatyka, prezentują zbliżoną formę do rzeczywistej składni języka.
Dokładny opis gramatyki znajduje się w pliku 
\path{lang-compiler/compiler/parsing/grammar.mly}. Jest bardziej skomplikowany
ze względu na rozpoznawanie bloków kodu z takim samym poziomem wcięcia na
poziomie parsera. Lepszym pod względem czytelności, jest wykonanie tej 
czynności na etapie lexera, tak jak to ma miejsce w $F\#$. Dokładniejszy opis 
sposobu parsowania składni bazującej na wcięciach, w tym i innych językach,
znajduje się w rozdziale TODO: rozdział. 

Dla prostoty zapisu przyjąłem że:
\begin{enumerate}
  \item * to wystąpienie poprzedzającego wyrażenia zero lub więcej razy,
  \item + to wystąpienie poprzedzającego wyrażenia jeden lub więcej razy.
\end{enumerate}

\begin{bnf*}
  \bnfprod{simple-if-exp}
    { \bnfts{ if } \bnfpn{simple-exp} \bnfts{ then } \bnfpn{simple-exp} 
      \bnfpn{simple-elif-exp} \bnfpn{simple-else-exp}
    }\\
  \bnfprod{if-exp}
    { \bnfts{ if } \bnfpn{simple-exp} \bnfpn{newline} \bnfts{ then } 
      \bnfpn{body-exp}+ \bnfpn{elif-exp}\ast \bnfpn{else-exp}
    }\\
  \bnfprod{simple-else-exp}
    {\bnfts{ else } \bnfpn{simple-exp} \bnfor \bnfes}\\
  \bnfprod{simple-elif-exp}
    {\bnfts{ elif } \bnfpn{simple-exp} \bnfts{ then } \bnfpn{simple-exp} \bnfor \bnfes}\\
  \bnfprod{elif-exp}
    {\bnfts{ elif } \bnfpn{body-exp}+ \bnfor \bnfpn{simple-elif-exp} 
     \bnfor \bnfes}\\
  \bnfprod{else-exp}
    {\bnfts{ else } \bnfpn{body-exp}+ \bnfor \bnfpn{simple-else-exp} 
     \bnfor \bnfes}\\
  \bnfprod{newline}
    {\bnftd{nowa linia}}
\end{bnf*}

\subsection{Wyrażenia arytmetyczne i logiczne}
Wyrażenia arytmetyczne i logiczne mają taką samą składnię jak w pozostałych
językach z rodziny ML.
\begin{bnf*}
  \bnfprod{bool-exp}
    { \bnfpn{simple-exp} \bnfpn{bool-op} \bnfpn{simple-exp} 
    }\\
  \bnfprod{arith-exp}
    { \bnfpn{simple-exp} \bnfpn{arith-op} \bnfpn{arith-exp} 
    }\\
  \bnfprod{arith-op}
    { \bnfts{+} \bnfor \bnfts{-} \bnfor \bnfts{*}
      \bnfor \bnfts{/} 
    }\\
  \bnfprod{bool-op}
    { \bnfts{\&\&} \bnfor \bnfts{$\|$} 
    }\\
\end{bnf*}

\section{Deklaracja funkcji (wyrażenie let)}

Argumenty funkcji muszą być w tym samym wierszu co słowo $let$. Po znaku 
$=$, ciało może być złożonym wyrażeniem o ile zaczyna się w następnym wierszu i 
jest w późniejszej kolumnie niż słowo $let$. Wyrażenie $let$ może być 
zdefiniowane w jednej linii, o ile jego ciało jest pojedyńczym wyrażeniem prostym.

TODO: Let z argumentami z adnotacjami.
TODO: Rekurencja

\begin{bnf*}
  \bnfprod{let-exp}
    { \bnfts{let} \bnfpn{identifier}+ \bnfts{=} \bnfpn{simple-exp} 
      \bnfor \bnfts{let} \bnfpn{identifier}+ \bnfts{=} 
      \bnfpn { newline } \bnfpn{body-exp}
    }\\
\end{bnf*}

\subsection{Wzajemnie rekurencyjne wyrażenia let}

TODO: 

% \begin{grammar}
% \begin{lstlisting}
% % <expression> ::= ['$+$' | '$-$'] <term> \{('$+$' | '$-$' ) <term>\}

% % <term> ::= <factor>* \{('$*$' | '$/$') <factor>\}

% % <factor> ::= "number" | <identifier>  | '(' <expression> ')'
% \end{lstlisting}
% \end{grammar}

\section{Rekordy}

\subsection{Deklaracja rekordu}

\begin{bnf*}
  \bnfprod{record-decl}
    { \bnfts{type} \bnfpn{identifier} \bnfts{=} \bnfts{'\{'} 
      \bnfpn{field-decl}+ \bnfts{'\}'} 
    }\\
  \bnfprod{field-decl}
    { \bnfpn{identifier} \bnfts{:} \bnfpn{identifier}+
      \bnfpn{newline} \bnfor \bnfpn{identifier} \bnfts{:} \bnfpn{identifier}+
      \bnfts{;}
    }\\
\end{bnf*}

\subsection{Literał rekordu}

Literał może być zdefiniowany w jednym lub wielu wierszach. W przypadku 
definicji w jednym wierszu, kolejne pola muszą być oddzielone średnikami. 
Średnik może być pominięty jeśli kolejne pola są oddzielone nową linią. 
Dle definicji wielowierszowej, klamra otwierająca i zamykająca muszą być w tej 
samej kolumnie.

\begin{bnf*}
\bnfprod{record-lit}
  { \bnfts{ type } \bnfpn{identifier} \bnfts{=} \bnfts{'\{'} 
    \bnfpn{field-lit}+ \bnfts{'\}'} 
  }\\
\bnfprod{field-lit}
  { \bnfpn{identifier} \bnfts{ = } \bnfpn{simple-exp}
    \bnfpn{newline} \bnfor \bnfpn{identifier} \bnfts{ = } \bnfpn{simple-exp}
    \bnfts{ ; }
  }\\
\end{bnf*}

\subsection{Uaktualnianie rekordu}

Rekordy w $Langu$, podobnie jak rekordy w $F\#$ i OCamlu, są trwałe. 
Uaktualnienie jednego z pól skutkuje stworzeniem nowego rekordu. Dlatego to
wyrażenie ma inną składnię niż ta znana z języków imperatywnych.

\begin{bnf*}
\bnfprod{record-update}
  { \bnfts{ \{ } \bnfpn{simple-exp} \bnfts{ with } 
    \bnfpn{field-update}+ \bnfts{ \} } 
  }\\
\bnfprod{field-update}
  { \bnfpn{identifier} \bnfts{=} \bnfpn{simple-exp}
    \bnfpn{newline} \bnfor \bnfpn{identifier} \bnfts{=} \bnfpn{simple-exp}
    \bnfts{;}
    TODO: samo pole 
  }\\
\end{bnf*}

\section{Klasy typów}

Jako, że w językach z rodziny ML nie występują klasy typów, ich składnie 
zdecydowałem się zapożyczyć z Haskella.

\subsection{Deklaracja klasy}

\subsection{Deklaracja instancji}

\section{Moduły}

Moduły w $Langu$ spełniają takie zadanie jak te w $F\#$ -- służą jako 
przestrzeń nazw dla związanych ze sobą definicji. Nie są odpowiednikiem 
systemu dużo bardziej zaawansowanych modułów SMLa czy OCamla.
Moduł zawiera: wyrażenia let, zagnieżdżone moduły, import innych 
modułów oraz deklaracje funkcji zewnętrznych. Nazwa modułu musi się zaczynać 
z wielkiej litery. 

TODO: Gramatyka modułu

\section{Tablice}

Zaimplementowane zostały jedynie tablice zawierające typ $int$. Tablice są 
ulotną strukturą danych. Na poziomie języka można stworzyć literał tablicy.
Zmiana i odczytanie komórki tablicy, bądź utworzenie niezainicjalizowanej tablicy odbywa się poprzez zewnętrzne funkcje zaimplementowane $C$. Tablice w 
langu są reprezentowane tak samo jak języku w $C$, jako spójny ciąg w pamięci.

Elementami literału tablicy, mogą być proste wyrażenia, oddzielone średnikiem. 
Podobnie jak w \newline $OCamlu$ i $F\#$ tablica zaczyna się od symbolu $[|$, a kończy symbolem $|]$.

\textbf{Uwaga.} Dla wielowierszowego literału tablicy, symbol rozpoczynający 
$[|$ i kończący $|]$, muszą być w tej samej kolumnie.

\section{Wołanie funkcji z $C$}

Mała część funkcjonalności języka została zaimplementowana z użyciem 
zewnętrznych funkcji w $C$ (wypisywanie oraz operacje na tablicy). Dlatego 
koniecznym było dołożenie wyrażeń pozwalających zadeklarować zewnętrzny symbol 
wraz z jego typem. Ich składnia jest prawie taka sama jak w OCamlu. Typy 
$Langa$ są dosłownie tłumaczone na typy w $C$, z wyjątkiem typu $unit$, który jest zamieniany na $bool$ (o rozmiarze jeden bajt).

TODO: Gramatyka external

% 1. Opis, szczegóły składni, (przykłady: każda cecha języka i krótki przykład)

% 1. Proste wyrażenia, rekurencja, let-polymorphism, rekordy,
% wzajemnie rekurencyjne funkcje na top levelu, klasy typów, proste moduły, 
% wyrażanie na top levelu, efekty uboczne, inferencja typów, anotacje.

% % \section{Klasy typów}

% 1. Wprowadzenie czym są 

% 2. Dlaczego? Jakie są alternatywy

% 3. Opis tego co zostało zaimplementowane, porównanie do innych języków, (Haskell,
% Rust, Scala)

\chapter{Kompilator}
\section{Etapy kompilacji}

Cały proces kompilacji, od momentu wczytania pliku z kodem źródłowym, do 
wyprodukowania pliku wykonywalnego, składa się z następujących etapów:
\begin{enumerate}
  \item Analiza leksykalna, w efekcie której otrzymujemy ciąg tokenów.
  TODO: w jakim pliku.
  \item Otrzymany ciąg jest następnie poddany analizie składniowej 
  (ang. parsing), która zgodnie z podaną gramatyką generuje \textit{drzewo 
  składni abstrakcyjnej (ang. abstract syntax tree)}. Węzły tego drzewa 
  zawierają jedno z wyrażeń, lecz nie posiadają informacji o typie tego
  wyrażenia. TODO: W jakim pliku.
  \item Następnie, wykonywana jest transformacja drzewa składni, która:

  \begin{enumerate}
    \item Dzięki przeprowadzeniu inferencji typów, nadaje każdemu wyrażeniu jego typ z języka $Lang$ (na późniejszym etapie, wyrażenia będą miał typ 
    z \textit{LLVM IR}). 
    \item Eliminuje zagnieżdżone wyrażenia $let$.
    \item Eliminuje moduły oraz otwarcia modułów poprzez translacje symboli do 
    ich w pełni kwalifikowanych nazw (ang. fully qualified name).
  \end{enumerate}

  \item Generowanie drzewa wyrażeń z LLVM IR. Jest to największy etap z całego 
  procesu kompilacji. Zamienia skomplikowane wyrażenia wysokopoziomowego języka
  na proste wyrażenia LLVM IR, które już łatwo mogą być przetłumaczone na 
  niskopoziomowe instrukcje.

  \item Konwersja drzewa wyrażeń LLVM IR na kod LLVM IR. Odbywa się to dzięki 
  interfejsowi programistycznemu (ang. api), udostępnionym przez oficjalną 
  bibliotekę LLVM dla $OCamla$.

\end{enumerate}

% 1. Jakie są etapy (lexer $\rightarrow$ parser $\rightarrow$ untyped ast $\rightarrow$ 
% typed ast bez zagnieżdżonych funkcji $\rightarrow$ generowanie kodu (ast high-ollvm)
% $\rightarrow$ wywoływanie funkcji z api llvma $\rightarrow$ llc $\rightarrow$ gcc i external) 

% 2. Krótko o każdym etapie

\section{Analiza leksykalna}

Do przeprowadzania analizy leksykalnej skorzystałem z biblioteki 
\textit{sedlex}. Jest to generator lekserów dla języka OCaml.

\subsection{Analiza wcięć}
 
Istnieje wiele języków programowania, realizujących ideę składni czułej na 
wcięcia. Sposób w jaki działa to w $F\#$ jest jednym z bardziej zaawansowanych,
bo pozwala na zdefiniowanie wielowierszowych aplikacji funkcji, warunków itp., 
bez użycia znaków przełamania wiersza bądź słów kluczowych znanych 
z języka OCaml (\textit{begin}, \textit{end}, \textit{;}). W $F\#$ istnieje 
także możliwość mieszania tych słów kluczowych z wcięciami. 

Analiza wcięć w $Langu$ jest zbliżona do tej w \textit{Pythonie}
\cite{python_indentation}. Dla każdego wiersza, 
na bieżąco jest obliczany numer kolumny pierwszego znaku (wcięcie). Długości 
wcięć z poprzednich wierszy są trzymane na stosie. Na początku na stosie
znajduję się wcięcie długości 0. Gdy wcięcie w obecnym wierszu jest większe od 
ostatniego na stosie, generowany jest token \textit{INDENT}, oznaczający 
początek wciętego bloku. Gdy wcięcie jest mniejsze od ostatniego na stosie, 
wszystkie większe są zdejmowane ze stosu i dla każdego zdjętego, generowany 
jest token \textit{DEDENT}. Oznacza on koniec wciętego bloku. Po zdjęciu 
wszystkich większych wcięć, ostatnie wcięcie, które zostanie na stosie musi być 
równe obecnemu wcięciu, w szczególności może być równe $0$. W przeciwnym 
przypadku, kod źródłowy jest źle wcięty i kompilator zwróci błąd.

\section{Parsowanie}

Popularnym narzędziem do generowania parserów jest \textit{Menhir}. Na 
\newline podstawie podanej gramatyki \textit{LR(1)}, generuje kod $OCamla$, 
który ją parsuje. Częściowo wspiera składnię \textit{EBNF}, m. in. operatory: $
+$, $?$, $\ast$. Zdecydowałem się skorzystać z tego narzędzia ze względu na 
łatwość użycia, możliwość interaktywnego debugowania gramatyki oraz 
ekspresywność składni w porównaniu do podobnych narzędzi takich jak \textit
{ocamlyacc}. Całość gramatyki znajduje się w pliku 
\path{lang-compiler/compiler/parsing/grammar.mly}. 
TODO: Może coś o kontekstach w F\#

% \section{Generowanie kodu}
\section{Częściowa aplikacja i funkcje}

Jak wspomniałem we wprowadzeniu, generowanie wszystkich funkcji w rozwiniętej 
formie (każda funkcja przyjmuje tylko jeden argument) jest nieoptymalne pod
względem długości kodu jak i szybkości jego wykonania. Pomimo że, aplikacja 
częściowa jest bardzo przydatną cechą języków funkcyjnych, to często funkcje
wywoływane są ze wszystkimi argumentami. W takich przypadkach chcielibyśmy 
korzystać z wywołania funkcji, które jest tak szybkie jak w \textit{C}. 
W kompilatorze \textit{Langa} pracowałem nad rozwiązaniem, które w pozostałych 
przypadkach korzystałoby z przekazywania argumentów funkcji przez rejestry i 
pozwalałoby na przekazywanie typów o różnych rozmiarach przez wartość. 

\subsection{Opis działania}

Podzielmy wszystkie wywołania funkcji na dwie grupy. Wywołania do znanych 
(ang. known call) i nie znanych funkcji (ang. unknown call). Znane funkcje to 
takie, których definicję można łatwo wskazać na etapie kompilacji. 
Na poniższym przykładzie, wywołana funkcja TODO: jest statycznie znana.

\begin{lstlisting}[frame=single, caption=Wywołanie statycznie znanej funkcji.]
TODO: Known call example
\end{lstlisting}

Przykładem nieznanych funkcji są funkcje, które: 
\begin{itemize}
  \item zostały podane jako argument,
  \item są wynikiem wywołania funkcji,
  \item są wynikiem częściowej aplikacji funkcji.
\end{itemize}

W tym przykładzie wywołane funkcje $a$, $b$ i $c$ są nieznane.

\begin{lstlisting}[frame=single, caption=Przykłady statycznie 
nieznanej funkcji.]
TODO: Unknown call example
\end{lstlisting}

\subsubsection{Wywołanie funkcji znanej}

Gdy funkcja, którą chcemy wywołać jest znana, możemy wyróżnić trzy przypadki 
ze względu na liczbę zaaplikowanych argumentów względem liczby argumentów
w definicji funkcji.

\begin{enumerate}
  \item Liczba zaaplikowanych argumentów jest mniejsza od liczby zdefiniowanych 
  argumentów. W tym przypadku utworzony zostaje obiekt reprezentujący częściowo
  zaaplikowaną funkcję. Zostaną w nim zapisane zaaplikowane argumenty oraz 
  wskaźnik na odpowiednią funkcję. Skopiowane argumenty i sam obiekt zostaną 
  utworzone na stercie.
  \item Zaaplikowanych argumentów jest tyle co zdefiniowanych. Funkcja zostanie
  wywołana w stylu z $C$. Jest to najbardziej optymalny przypadek wywołania 
  funkcji i nie powoduje on zaalokowania żadnej dodatkowej pamięci. Jeśli 
  początkowe argumenty mieszczą się w rejestrach to mogą zostać przez nie 
  przekazane.
  \item Zaaplikowanych argumentów może być więcej niż zdefiniowanych jeśli wynikiem wywoływanej funkcji jest funkcja. Niech $n$ to będzie liczba 
  zdefiniowanych argumentów. Najpierw nastąpi wywołanie znanej funkcji z 
  pierwszymi $n$ argumentami. Do wyniku pierwszego wywołania, który teraz jest
  nieznaną funkcją, zostaną zaaplikowane pozostałe argumenty. W tym momencie 
  zastosowany zostanie jeden z przypadków dla wywołań nieznanych funkcji.

TODO: Coś o tym że funkcje / symbole trzymane są w środowisku z informacją 
known / unknown.
\end{enumerate}

\subsubsection{Wywołanie funkcji nieznanej}

Wywołania funkcji nieznanych podzielimy na takie, których wynikiem jest dowolna
funkcja $ a \rightarrow b $ i takie których wynikiem jest wartość. Podczas
fazy inferencji typów, obliczany jest typ każdego wyrażenia, więc kompilator
jest w stanie określić do której grupy należy dana aplikacja funkcji. Każda 
nieznana lub częściowo zaaplikowana funkcja jest reprezentowana przez strukturę 
(taką jak w $C$), 
zawierającą następujące pola:

\begin{itemize}
  \item wskaźnik na funkcje,
  \item wskaźnik na środowisko (zapamiętane argumenty), które jest pamiętane 
  jako spójny ciąg bajów. TODO: Można też tablice wskaźników na argumenty i 
  dlaczego tak nie zrobiłem
  \item liczba bajtów w środowisku,
  \item liczba obecnie zaaplikowanych argumentów
  \item pozostała liczba argumentów koniecznych do zaaplikowana, aby należało 
  wywołać wskazywaną funkcje.
\end{itemize}

Definicja takiej struktury w $C$ wyglądałaby następująco:

\begin{lstlisting}[frame=single, caption=Rozwinięta funkcja w OCamlu.]
struct function {
    void (*fn)();
    uchar *args;
    uchar left_args;
    uchar arity;
    int used_bytes;   
};
\end{lstlisting}

Wskaźnik na funkcje \textit{fn}, przed wywołaniem musi zostać zrzutowany na 
prawidłowy typ. Dla aplikacji funkcji, których wynikiem jest funkcja, typ 
wynikowy funkcji \textit{fn} to struktura \textit{function}. Jako argumenty 
funkcji \textit{fn}, poza argumentami podanymi w aplikacji funkcji, przekazane 
zostaną dodatkowo: wskaźnik na środowisko i liczba aplikowanych argumentów.
Funkcja wołana jest odpowiedzialna za nadmiarowe argumenty i przekazanie ich 
dalej.

Aplikacja funkcji nie zawsze musi się wiązać z faktycznym wywołaniem funkcji.
Na poniższym przykładzie w pierwszym przypadku funkcja \textit{TODO:}
zostanie wywołana, a w drugim, pomimo aplikacji tych samych argumentów, nic nie 
zostanie wywołane.
\begin{lstlisting}[frame=single, caption=Wywołanie funkcji zależy od podanego
argumentu. OCaml.]
TODO: Przykład z wywołaniem i nie wywołaniem częściowo 
zaaplikowanej funkcji  
\end{lstlisting}

Dla każdego wywołania nieznanej funkcji, generowany jest dodatkowy kod, który
jest odpowiedzialny za sprawdzenie, czy aplikowaną funkcje faktycznie trzeba 
wywołać, czy jedynie dopisać dodatkowe argumenty do środowiska.

TODO: o dynamicznych przypadkach

TODO: wywoływanie funkcji, przypadki z przykładami
TODO: Przykład w pseudokodzie? Może algorytm

% TODO: Co to unknown i know call 

TODO: generowanie każdej funkcji


% 1. Dlaczego jest to nietrywialne

% 2. Jakie miałem cele 

% 3. Jak to działa u mnie 

% 4. Przykład (wygenerowanego pseudo-kodu)

\subsubsection{Generowanie funkcji}

\subsection{Porównanie z innymi implementacjami}

1. Push/enter vs eval/apply

Porównanie z pracą "Making a fast curry: ..."

\section{Zagnieżdżone funkcje}

1. Co to są zagnieżdżone funkcje 

2. Na czym polega trudność w ich implementacji

3. Jak zostały zaimplementowane: lambda lifting + closure conversion + 
wykorzystanie aplikacji częściowej

\section{Rekordy}

Implementacja, porównanie do rekordów w F\#.

\section{Let polimorfizm}

1. Krótki opis, czym jest let-polimorfizm

2. Sposoby implementacji w różnych językach, zalety i wady 

3. Sposób implementacji u mnie

\section{Inferencja typów}
????
1. Po co? Jak działa u mnie

\section{Klasy typów}

1. Czym są? Po co? 

2. Sposoby implementowania, porównanie do pracy TODO

3. Jak zostały zaimplementowane, dlaczego tak

\chapter{Podsumowanie}

\section{Wnioski}

\section{Dalsze prace}

\chapter{Instrukcja obsługi}

\section{Instalacja}

\section{Sposób użycia z przykładami}

\section{Użyte narzędzia i biblioteki}

\section{Struktura projektu}

%%%%% BIBLIOGRAFIA

\begin{thebibliography}{1}

\bibitem{sml_proposal} 
The Standard ML Core Language, by Robin Milner, July 1984.
\\\texttt{http://sml-family.org/history/SML-proposal-7-84.pdf}

\bibitem{modules_vs_typeclasses} 
ML Modules and Haskell Type Classes:
A Constructive Comparison
Stefan Wehr and Manuel M. T. Chakravarty
\\\texttt{https://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf}

\bibitem{no_hkt_in_rust} 
Higher kinded polymorphism - Rust Github issues.
\\\texttt{https://github.com/rust-lang/rfcs/issues/324}

\bibitem{cpp_bind} 
std::bind - C++ Reference
\\\texttt{https://en.cppreference.com/w/cpp/utility/functional/bind}

\bibitem{fslang_typeclass} 
TODO: FS lang, user voice - type classes
\\\texttt{https://fslang.uservoice.com/forums/245727-f-language/filters/top}

\bibitem{python_indentation} 
Indentation. Python Reference Manual.
\\\texttt{https://docs.python.org/2.5/ref/indentation.html}

\end{thebibliography}

\end{document}
